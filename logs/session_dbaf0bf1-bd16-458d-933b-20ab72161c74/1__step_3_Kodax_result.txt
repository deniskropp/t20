{
  "frontend_code": {
    "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>TAS Data Annotation Tool</title>\n    <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap\" rel=\"stylesheet\">\n    <style>\n        /* Design System Styles */\n        :root {\n            --primary-color: #4A90E2;\n            --secondary-color: #50E3C2;\n            --accent-color: #F5A623;\n            --background-color: #F8F9FA;\n            --surface-color: #FFFFFF;\n            --text-primary: #333333;\n            --text-secondary: #666666;\n            --border-color: #DDDDDD;\n            --font-family: 'Inter', sans-serif;\n            --h1-font-size: 32px;\n            --h1-font-weight: 700;\n            --h1-line-height: 40px;\n            --h2-font-size: 24px;\n            --h2-font-weight: 600;\n            --h2-line-height: 32px;\n            --body-large-font-size: 16px;\n            --body-large-font-weight: 400;\n            --body-large-line-height: 24px;\n            --body-small-font-size: 14px;\n            --body-small-font-weight: 400;\n            --body-small-line-height: 20px;\n            --label-font-size: 12px;\n            --label-font-weight: 500;\n            --label-line-height: 16px;\n            --border-radius: 8px;\n            --input-padding: 12px 16px;\n            --button-padding: 12px 24px;\n            --list-item-padding: 10px 0;\n            --list-item-gap: 10px;\n        }\n\n        body { \n            font-family: var(--font-family);\n            background-color: var(--background-color);\n            color: var(--text-primary);\n            margin: 0;\n            padding: 0;\n            display: flex;\n            justify-content: center;\n            align-items: flex-start;\n            min-height: 100vh;\n            box-sizing: border-box;\n        }\n\n        .container { \n            width: 100%;\n            max-width: 1200px;\n            margin: 40px auto;\n            padding: 0 20px;\n            box-sizing: border-box;\n        }\n\n        .screen {\n            background-color: var(--surface-color);\n            padding: 40px;\n            border-radius: var(--border-radius);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.05);\n            margin-bottom: 40px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            text-align: center;\n        }\n\n        .screen.goal-input {\n            justify-content: center;\n            min-height: calc(100vh - 80px); /* Adjust for margin */\n        }\n\n        .screen.tas-review {\n            flex-direction: row;\n            align-items: flex-start;\n            text-align: left;\n            justify-content: space-between;\n            flex-wrap: wrap;\n        }\n\n        .logo {\n            margin-bottom: 20px;\n            width: 60px; /* Adjust size as needed */\n            height: 60px;\n        }\n        .logo svg {\n            width: 100%;\n            height: 100%;\n        }\n\n        h1 {\n            font-size: var(--h1-font-size);\n            font-weight: var(--h1-font-weight);\n            line-height: var(--h1-line-height);\n            color: var(--text-primary);\n            margin-bottom: 10px;\n        }\n\n        h2 {\n            font-size: var(--h2-font-size);\n            font-weight: var(--h2-font-weight);\n            line-height: var(--h2-line-height);\n            color: var(--text-primary);\n            margin-bottom: 10px;\n        }\n\n        .sub-heading {\n            font-size: var(--body-large-font-size);\n            font-weight: var(--body-large-font-weight);\n            line-height: var(--body-large-line-height);\n            color: var(--text-secondary);\n            margin-bottom: 30px;\n        }\n\n        .input-field {\n            width: 100%;\n            max-width: 600px;\n            padding: var(--input-padding);\n            border: 1px solid var(--border-color);\n            border-radius: var(--border-radius);\n            font-size: var(--body-large-font-size);\n            font-weight: var(--body-large-font-weight);\n            line-height: var(--body-large-line-height);\n            box-sizing: border-box;\n            margin-bottom: 20px;\n            color: var(--text-primary);\n            background-color: var(--surface-color);\n        }\n        .input-field:focus {\n            outline: none;\n            border-color: var(--primary-color);\n            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.3);\n        }\n\n        .button {\n            border: none;\n            border-radius: var(--border-radius);\n            padding: var(--button-padding);\n            font-size: var(--body-large-font-size);\n            font-weight: var(--button-font-weight);\n            cursor: pointer;\n            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;\n            text-decoration: none;\n            display: inline-block;\n            margin: 5px;\n        }\n\n        .button.primary {\n            background-color: var(--primary-color);\n            color: white;\n            font-weight: 600;\n        }\n        .button.primary:hover {\n            background-color: #3a7bc8;\n        }\n\n        .button.secondary {\n            background-color: transparent;\n            color: var(--primary-color);\n            border: 1px solid var(--primary-color);\n            font-weight: 600;\n        }\n        .button.secondary:hover {\n            background-color: rgba(74, 144, 226, 0.1);\n        }\n\n        .button.tertiary {\n            background-color: transparent;\n            color: var(--text-secondary);\n            font-weight: 500;\n            padding: 8px 16px;\n        }\n        .button.tertiary:hover {\n            color: var(--primary-color);\n        }\n\n        .tas-review .left-panel, .tas-review .right-panel {\n            flex: 1;\n            min-width: 300px;\n            padding: 20px;\n            box-sizing: border-box;\n        }\n        .tas-review .left-panel {\n            border-right: 1px solid var(--border-color);\n        }\n        .tas-review .right-panel {\n            display: flex;\n            flex-direction: column;\n            align-items: flex-start;\n        }\n\n        .tas-review h2 {\n            margin-bottom: 20px;\n        }\n\n        .tas-list {\n            list-style: none;\n            padding: 0;\n            width: 100%;\n        }\n\n        .tas-list .list-item {\n            display: flex;\n            align-items: center;\n            gap: var(--list-item-gap);\n            padding: var(--list-item-padding);\n            border-bottom: 1px solid var(--border-color);\n            font-size: var(--body-large-font-size);\n            font-weight: var(--body-large-font-weight);\n            line-height: var(--body-large-line-height);\n            color: var(--text-primary);\n        }\n        .tas-list .list-item:last-child {\n            border-bottom: none;\n        }\n\n        .tas-list .list-item .drag-handle {\n            cursor: grab;\n            color: var(--text-secondary);\n            font-size: 1.2em;\n            user-select: none;\n        }\n\n        .tas-list .list-item .editable-input {\n            flex-grow: 1;\n            font-size: var(--body-large-font-size);\n            font-weight: var(--body-large-font-weight);\n            line-height: var(--body-large-line-height);\n            border: none;\n            background: transparent;\n            color: var(--text-primary);\n            padding: 0;\n        }\n        .tas-list .list-item .editable-input:focus {\n            outline: none;\n            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.3);\n            border-radius: 4px;\n        }\n\n        .review-actions {\n            margin-top: 30px;\n            width: 100%;\n            display: flex;\n            justify-content: flex-start;\n            gap: 10px;\n        }\n        .right-panel .actions {\n            margin-top: 20px;\n            display: flex;\n            justify-content: flex-start;\n        }\n\n        /* Responsive Adjustments */\n        @media (max-width: 768px) {\n            .screen.tas-review {\n                flex-direction: column;\n                align-items: center;\n            }\n            .tas-review .left-panel, .tas-review .right-panel {\n                border-right: none;\n                border-bottom: 1px solid var(--border-color);\n                width: 100%;\n                max-width: 500px;\n            }\n            .tas-review .left-panel {\n                 border-bottom: 1px solid var(--border-color);\n            }\n            .tas-review .right-panel {\n                border-bottom: none;\n            }\n            .review-actions, .right-panel .actions {\n                justify-content: center;\n                flex-wrap: wrap;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div id=\"goal-input-screen\" class=\"screen goal-input\">\n            <div class=\"logo\">\n                <svg viewBox=\"0 0 60 60\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <title>TAS Tool Logo</title>\n                    <line x1=\"10\" y1=\"30\" x2=\"30\" y2=\"10\" stroke=\"#4A90E2\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                    <line x1=\"30\" y1=\"10\" x2=\"50\" y2=\"30\" stroke=\"#4A90E2\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                    <line x1=\"30\" y1=\"10\" x2=\"30\" y2=\"50\" stroke=\"#50E3C2\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                </svg>\n            </div>\n            <h1>Define Your Objective</h1>\n            <p class=\"sub-heading\">Enter your high-level goal for the LLM fine-tuning dataset.</p>\n            <input type=\"text\" id=\"high-level-goal-input\" class=\"input-field\" placeholder=\"e.g., Create a dataset for LLM fine-tuning towards internalized TAS expertise\">\n            <button id=\"generate-tas-button\" class=\"button primary\">Generate TAS Plan</button>\n        </div>\n\n        <div id=\"tas-review-screen\" class=\"screen tas-review\" style=\"display: none;\">\n            <div class=\"left-panel\">\n                <h2>Generated TAS Plan</h2>\n                <ul id=\"tas-plan-list\" class=\"tas-list\">\n                    <!-- TAS items will be populated here -->\n                </ul>\n                <div class=\"review-actions\">\n                    <button id=\"approve-dataset-button\" class=\"button primary\">Approve & Add to Dataset</button>\n                    <button id=\"reject-plan-button\" class=\"button secondary\">Reject Plan</button>\n                </div>\n            </div>\n            <div class=\"right-panel\">\n                <h2>High-level Goal</h2>\n                <p id=\"review-goal-text\" class=\"sub-heading\"></p>\n                <div class=\"actions\">\n                    <button id=\"edit-goal-button\" class=\"button tertiary\">Edit Goal</button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        const goalInputScreen = document.getElementById('goal-input-screen');\n        const tasReviewScreen = document.getElementById('tas-review-screen');\n        const highLevelGoalInput = document.getElementById('high-level-goal-input');\n        const generateTasButton = document.getElementById('generate-tas-button');\n        const tasPlanList = document.getElementById('tas-plan-list');\n        const reviewGoalText = document.getElementById('review-goal-text');\n        const approveDatasetButton = document.getElementById('approve-dataset-button');\n        const rejectPlanButton = document.getElementById('reject-plan-button');\n        const editGoalButton = document.getElementById('edit-goal-button');\n\n        let currentHighLevelGoal = '';\n        let currentTasPlan = [];\n        let dataset = [];\n\n        // Dummy TAS data for demonstration. In a real app, this would come from an LLM.\n        const dummyTasData = [\n            \"Define the overall objective and scope.\",\n            \"Break down the objective into smaller, actionable tasks.\",\n            \"Identify necessary resources for each task.\",\n            \"Assign responsibilities for each task.\",\n            \"Define a timeline for task completion.\",\n            \"Execute each task according to the plan.\",\n            \"Monitor progress and identify deviations.\",\n            \"Adjust the plan as needed based on feedback.\",\n            \"Validate the final outcome against the objective.\",\n            \"Document findings and lessons learned.\"\n        ];\n\n        // Mock LLM response function\n        function generateTasPlan(goal) {\n            // In a real scenario, this would call a backend API that interacts with an LLM.\n            console.log(`Simulating LLM call for goal: ${goal}`);\n            // For now, we'll just return a subset of dummy data or a modified version.\n            const plan = dummyTasData.slice(0, Math.min(dummyTasData.length, Math.floor(Math.random() * 5) + 5)); // Randomly pick 5-9 steps\n            return plan.map((step, index) => ({ id: `tas-${index}-${Date.now()}`, text: step }));\n        }\n\n        function renderTasPlan() {\n            tasPlanList.innerHTML = '';\n            currentTasPlan.forEach((item, index) => {\n                const listItem = document.createElement('li');\n                listItem.classList.add('list-item');\n                listItem.dataset.id = item.id;\n\n                const dragHandle = document.createElement('span');\n                dragHandle.classList.add('drag-handle');\n                dragHandle.innerHTML = '⠿'; // Unicode for drag handle\n                listItem.appendChild(dragHandle);\n\n                const input = document.createElement('input');\n                input.type = 'text';\n                input.classList.add('editable-input');\n                input.value = item.text;\n                input.addEventListener('input', (e) => {\n                    currentTasPlan[index].text = e.target.value;\n                });\n                listItem.appendChild(input);\n\n                tasPlanList.appendChild(listItem);\n            });\n        }\n\n        generateTasButton.addEventListener('click', () => {\n            currentHighLevelGoal = highLevelGoalInput.value.trim();\n            if (currentHighLevelGoal) {\n                // Simulate fetching TAS plan from LLM\n                currentTasPlan = generateTasPlan(currentHighLevelGoal);\n                reviewGoalText.textContent = currentHighLevelGoal;\n                renderTasPlan();\n                goalInputScreen.style.display = 'none';\n                tasReviewScreen.style.display = 'flex';\n            } else {\n                alert('Please enter a high-level goal.');\n            }\n        });\n\n        approveDatasetButton.addEventListener('click', () => {\n            if (!currentHighLevelGoal || currentTasPlan.length === 0) {\n                alert('No goal or TAS plan to approve.');\n                return;\n            }\n            \n            const validatedEntry = {\n                high_level_goal: currentHighLevelGoal,\n                tas_plan: currentTasPlan.map(item => item.text)\n            };\n            dataset.push(validatedEntry);\n            console.log('Dataset updated:', dataset);\n            alert('Plan approved and added to dataset!');\n            \n            // Reset for next entry\n            highLevelGoalInput.value = '';\n            currentHighLevelGoal = '';\n            currentTasPlan = [];\n            tasPlanList.innerHTML = '';\n            goalInputScreen.style.display = 'flex';\n            tasReviewScreen.style.display = 'none';\n        });\n\n        rejectPlanButton.addEventListener('click', () => {\n            // Optionally provide feedback on rejection, or just reset\n            alert('Plan rejected. Please try generating again or edit the goal.');\n            highLevelGoalInput.value = currentHighLevelGoal; // Keep the goal to allow editing/regenerating\n            tasReviewScreen.style.display = 'none';\n            goalInputScreen.style.display = 'flex';\n            currentTasPlan = []; // Clear the plan\n        });\n\n        editGoalButton.addEventListener('click', () => {\n            highLevelGoalInput.value = currentHighLevelGoal;\n            tasReviewScreen.style.display = 'none';\n            goalInputScreen.style.display = 'flex';\n            currentTasPlan = []; // Clear the plan as it might be outdated\n        });\n\n        // Basic drag-and-drop functionality for list items (requires a library or more complex implementation for full robustness)\n        // For this example, we'll simulate the reordering by just logging.\n        // In a real implementation, you'd use a library like SortableJS.\n        tasPlanList.addEventListener('dragstart', (e) => {\n            if (e.target.classList.contains('list-item')) {\n                e.dataTransfer.effectAllowed = 'move';\n                e.dataTransfer.setData('text/plain', e.target.dataset.id);\n                e.target.classList.add('dragging');\n            }\n        });\n\n        tasPlanList.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.dataTransfer.dropEffect = 'move';\n        });\n\n        tasPlanList.addEventListener('drop', (e) => {\n            e.preventDefault();\n            const draggedId = e.dataTransfer.getData('text/plain');\n            const targetElement = e.target.closest('.list-item');\n            if (!targetElement) return;\n\n            const draggedIndex = Array.from(tasPlanList.children).findIndex(item => item.dataset.id === draggedId);\n            const targetIndex = Array.from(tasPlanList.children).findIndex(item => item.dataset.id === targetElement.dataset.id);\n\n            if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) return;\n\n            const [movedItem] = currentTasPlan.splice(draggedIndex, 1);\n            currentTasPlan.splice(targetIndex, 0, movedItem);\n\n            renderTasPlan(); // Re-render the list to reflect the new order\n        });\n\n        tasPlanList.addEventListener('dragend', (e) => {\n            if (e.target.classList.contains('list-item')) {\n                e.target.classList.remove('dragging');\n            }\n        });\n\n        // Function to export the dataset (e.g., to JSON)\n        function exportDataset() {\n            const dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(dataset, null, 2));\n            const downloadAnchorNode = document.createElement('a');\n            downloadAnchorNode.setAttribute('href', dataStr);\n            downloadAnchorNode.setAttribute('download', 'tas_finetuning_dataset.json');\n            document.body.appendChild(downloadAnchorNode);\n            downloadAnchorNode.click();\n            downloadAnchorNode.remove();\n        }\n\n        // Example: Add a button to export the dataset (this would typically be outside the main flow)\n        // For demonstration, we'll add it to the console log.\n        // In a real UI, you'd have a dedicated export button.\n        console.log('Dataset ready for export. Call exportDataset() to download.');\n\n    </script>\n</body>\n</html>\n",
    "css": "/* CSS is embedded within the HTML for simplicity in this example. */\n/* In a production environment, this would be in a separate .css file. */\n",
    "javascript": "/* JavaScript is embedded within the HTML for simplicity in this example. */\n/* In a production environment, this would be in a separate .js file. */\n"
  },
  "backend_code": {
    "description": "The backend for this annotation tool will be a simple RESTful API. For this implementation, we'll use Python with Flask, as it's lightweight and suitable for this task. The API will handle receiving high-level goals, generating TAS plans (simulated here), storing approved plans, and exporting the dataset.",
    "language": "Python",
    "framework": "Flask",
    "endpoints": [
      {
        "method": "POST",
        "path": "/generate_tas",
        "description": "Receives a high-level goal and returns a generated TAS plan.",
        "request_body": {
          "type": "object",
          "properties": {
            "high_level_goal": {
              "type": "string",
              "description": "The user-provided high-level goal."
            }
          },
          "required": ["high_level_goal"]
        },
        "response_body": {
          "type": "object",
          "properties": {
            "tas_plan": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "id": {"type": "string"},
                  "text": {"type": "string"}
                },
                "required": ["id", "text"]
              }
            }
          },
          "required": ["tas_plan"]
        },
        "implementation_notes": "This endpoint would integrate with an LLM service to generate the TAS plan. For this example, it simulates the response using predefined data."
      },
      {
        "method": "POST",
        "path": "/save_annotation",
        "description": "Receives an approved high-level goal and its TAS plan, and saves it to the dataset.",
        "request_body": {
          "type": "object",
          "properties": {
            "high_level_goal": {
              "type": "string"
            },
            "tas_plan": {
              "type": "array",
              "items": {"type": "string"}
            }
          },
          "required": ["high_level_goal", "tas_plan"]
        },
        "response_body": {
          "type": "object",
          "properties": {
            "message": {"type": "string"}
          }
        },
        "implementation_notes": "This endpoint would append the validated entry to an in-memory list or a database. For this example, it's handled client-side."
      },
      {
        "method": "GET",
        "path": "/export_dataset",
        "description": "Exports the current dataset in JSON format.",
        "response_body": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "high_level_goal": {"type": "string"},
              "tas_plan": {"type": "array", "items": {"type": "string"}}
            },
            "required": ["high_level_goal", "tas_plan"]
          }
        },
        "implementation_notes": "This endpoint would return the stored dataset. For this example, client-side export is implemented."
      }
    ],
    "data_storage": "In-memory list (for demonstration purposes). In a production environment, this would be a database (e.g., PostgreSQL, SQLite) or a file-based storage.",
    "example_implementation": "```python\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS\nimport uuid\n\napp = Flask(__name__)\nCORS(app) # Allow cross-origin requests from the frontend\n\n# In-memory storage for the dataset\ndataset = []\n\n# Dummy LLM response simulation\n# In a real application, this would call an LLM API\ndef simulate_llm_tas_generation(goal):\n    print(f\"Simulating LLM TAS generation for goal: {goal}\")\n    # This is a placeholder. A real implementation would process the goal and return a structured TAS plan.\n    # For this example, we'll just return a generic plan based on the goal.\n    generic_steps = [\n        \"Understand the core request.\",\n        \"Identify key entities and actions.\",\n        \"Break down the request into logical steps.\",\n        \"Ensure each step is atomic and actionable.\",\n        \"Order steps sequentially.\",\n        \"Review for clarity and completeness.\",\n        \"Refine steps based on feedback.\",\n        \"Finalize the plan.\"\n    ]\n    # Simulate a plan of 5-8 steps\n    num_steps = 5 + hash(goal) % 4 # Simple way to get variety\n    selected_steps = generic_steps[:num_steps]\n    \n    tas_plan = []\n    for i, step_text in enumerate(selected_steps):\n        tas_plan.append({\"id\": str(uuid.uuid4()), \"text\": step_text})\n    return tas_plan\n\n@app.route('/generate_tas', methods=['POST'])\ndef generate_tas():\n    data = request.get_json()\n    high_level_goal = data.get('high_level_goal')\n\n    if not high_level_goal:\n        return jsonify({'error': 'high_level_goal is required'}), 400\n\n    tas_plan = simulate_llm_tas_generation(high_level_goal)\n    return jsonify({'tas_plan': tas_plan})\n\n@app.route('/save_annotation', methods=['POST'])\ndef save_annotation():\n    data = request.get_json()\n    high_level_goal = data.get('high_level_goal')\n    tas_plan_texts = data.get('tas_plan')\n\n    if not high_level_goal or not tas_plan_texts:\n        return jsonify({'error': 'high_level_goal and tas_plan are required'}), 400\n\n    validated_entry = {\n        'high_level_goal': high_level_goal,\n        'tas_plan': tas_plan_texts\n    }\n    dataset.append(validated_entry)\n    print(f\"Saved annotation: {validated_entry}\")\n    return jsonify({'message': 'Annotation saved successfully'}), 201\n\n@app.route('/export_dataset', methods=['GET'])\ndef export_dataset():\n    # The schema requires an array of objects with high_level_goal and tas_plan (as array of strings)\n    formatted_dataset = [\n        {\n            'high_level_goal': entry['high_level_goal'],\n            'tas_plan': [step['text'] for step in entry['tas_plan']] # Extracting only the text for the final dataset\n        }\n        for entry in dataset\n    ]\n    return jsonify(formatted_dataset)\n\nif __name__ == '__main__':\n    # In a real deployment, use a production-ready WSGI server like Gunicorn\n    app.run(debug=True, port=5000) # Runs on http://127.0.0.1:5000/\n```"
  }
}