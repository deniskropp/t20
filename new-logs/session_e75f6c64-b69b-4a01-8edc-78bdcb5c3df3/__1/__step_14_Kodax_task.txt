The overall goal is: 'Bootstrap a Bootstrap 5 powered frontend for the Qdrant Service'

Your role's specific goal is: 'Implement designs into clean, modular, and performant code, focusing on responsive design and accessibility.'
Your specific sub-task is: 'Prepare the frontend application for deployment, including build processes and configuration for a production environment.'

The team's roles are:
    [Role(title='Task-Agnostic Step (TAS) extractor', purpose='Identify and extract granular, actionable steps from high-level goals, ensuring no task-specific knowledge is required for this extraction process. These steps should be general enough to be assigned to various specialized agents.'), Role(title='Prompt Engineer', purpose='Refine system prompts for AI agents based on their roles and the specific tasks they are assigned. This ensures clear communication, effective workflow structuring, and optimal performance of each agent.'), Role(title='Designer', purpose='Generate aesthetic layouts, color palettes, typography, and UI flows for the frontend. Ensure designs are accessible, visually balanced, and align with the overall project requirements.'), Role(title='Engineer', purpose='Implement the designed frontend components into clean, modular, and performant code. Focus on responsive design, accessibility, and seamless integration with the backend API.')]

Please use the following outputs from the other agents as your input:

--- Artifact 'files' from (User) in [initial]:
{
    "path": "main.py",
    "content": "import traceback\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List, Dict, Any\nfrom qdrant_client import QdrantClient, models\nimport time\nimport base64\nimport io\nfrom PIL import Image\nimport open_clip\nimport uuid\nimport hashlib\nimport torch\n\n# --- Configuration ---\nQDRANT_HOST = \"localhost\"\nQDRANT_PORT = 6333\nSIMILARITY_THRESHOLD = 0.75 # Example threshold\nIMAGE_COLLECTION_NAME = \"image_metadata\"\n\n# Model-specific configurations, including vector dimensions.\nMODEL_CONFIG = {\n    \"ViT-B-32\": {\"dim\": 512, \"description\": \"ViT-B-32 from OpenAI\", \"pretrained\": \"openai\"},\n    \"RN50\": {\"dim\": 1024, \"description\": \"ResNet-50 from OpenAI\", \"pretrained\": \"openai\"},\n}\n\n# --- Pydantic Models ---\nclass ModelInfo(BaseModel):\n    name: str\n    description: str\n    dim: int\n\nclass TextBenchmarkRequest(BaseModel):\n    query: str\n    model_name: str\n\nclass ImageBenchmarkRequest(BaseModel):\n    image_base64: str\n    model_name: str\n\nclass IndexImageRequest(BaseModel):\n    image_base64: str\n    metadata: Dict[str, Any]\n\nclass SearchResult(BaseModel):\n    image_id: str\n    metadata: Dict[str, Any]\n    score: float\n\nclass BenchmarkResponse(BaseModel):\n    model_name: str\n    results: List[SearchResult]\n    latency_ms: float\n\n# --- FastAPI App Setup ---\napp = FastAPI()\n\n# --- Qdrant Client Initialization ---\nclass QdrantService:\n    def __init__(self, host: str, port: int):\n        #self.client = QdrantClient(host=host, port=port)\n        self.client = QdrantClient(path=\"./qdrant_data\")  # Using local storage for simplicity\n        self._loaded_models = {}\n        self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        print(f\"Using device: {self.device}\")\n\n\n    def get_available_models(self) -> List[ModelInfo]:\n        # In a real scenario, this could also query a model registry or check available collections.\n        # For now, we use the configured models.\n        model_names = [\n            ModelInfo(name=name, description=config[\"description\"], dim=config[\"dim\"]) for name, config in MODEL_CONFIG.items()\n        ]\n        return model_names\n\n    def _get_model_collection_name(self, model_name: str) -> str:\n        return f\"namespace-{model_name}\"\n\n    def _load_model(self, model_name: str):\n        if model_name not in self._loaded_models:\n            print(f\"Loading model {model_name}...\")\n            pretrained = MODEL_CONFIG[model_name].get(\"pretrained\", \"\")\n            model, _, preprocess = open_clip.create_model_and_transforms(\n                model_name, pretrained=pretrained, device=self.device\n            )\n            tokenizer = open_clip.get_tokenizer(model_name)\n            self._loaded_models[model_name] = (model, preprocess, tokenizer)\n        return self._loaded_models[model_name]\n\n    def _get_embedding(self, text_or_image: Any, model_name: str) -> List[float]:\n        model, preprocess, tokenizer = self._load_model(model_name)\n\n        with torch.no_grad(), torch.cuda.amp.autocast():\n            if isinstance(text_or_image, str):\n                text = tokenizer(text_or_image).to(self.device)\n                embedding = model.encode_text(text)\n            elif isinstance(text_or_image, Image.Image):\n                image = preprocess(text_or_image).unsqueeze(0).to(self.device)\n                embedding = model.encode_image(image)\n            else:\n                raise ValueError(\"Input must be a string or a PIL Image.\")\n\n            embedding /= embedding.norm(dim=-1, keepdim=True)\n\n        return embedding.cpu().numpy().flatten().tolist()\n\n    def search_by_text(self, query: str, model_name: str, limit: int = 10) -> List[SearchResult]:\n        collection_name = self._get_model_collection_name(model_name)\n        try:\n            query_vector = self._get_embedding(query, model_name)\n            \n            search_result = self.client.search(\n                collection_name=collection_name,\n                query_vector=query_vector,\n                limit=limit,\n                query_filter=models.Filter(\n                    must_not=[\n                        models.FieldCondition(key=\"score\", range=models.Range(lt=SIMILARITY_THRESHOLD))\n                    ]\n                )\n            )\n            \n            results = []\n            for hit in search_result:\n                # Fetch metadata from the metadata collection\n                metadata_response = self.client.retrieve(\n                    collection_name=IMAGE_COLLECTION_NAME,\n                    ids=[hit.id],\n                    with_payload=True\n                )\n                if metadata_response:\n                    results.append(SearchResult(\n                        image_id=hit.id,\n                        metadata=metadata_response[0].payload,\n                        score=hit.score\n                    ))\n            return results\n        except Exception as e:\n            print(f\"Error searching text in {model_name}: {e}\")\n            raise HTTPException(status_code=500, detail=f\"Error performing text search for model {model_name}\")\n\n    def search_by_image(self, image_base64: str, model_name: str, limit: int = 10) -> List[SearchResult]:\n        collection_name = self._get_model_collection_name(model_name)\n        try:\n            image_bytes = base64.b64decode(image_base64)\n            image = Image.open(io.BytesIO(image_bytes))\n            \n            query_vector = self._get_embedding(image, model_name)\n\n            search_result = self.client.search(\n                collection_name=collection_name,\n                query_vector=query_vector,\n                limit=limit,\n                query_filter=models.Filter(\n                    must_not=[\n                        models.FieldCondition(key=\"score\", range=models.Range(lt=SIMILARITY_THRESHOLD))\n                    ]\n                )\n            )\n            \n            results = []\n            for hit in search_result:\n                # Fetch metadata from the metadata collection\n                metadata_response = self.client.retrieve(\n                    collection_name=IMAGE_COLLECTION_NAME,\n                    ids=[hit.id],\n                    with_payload=True\n                )\n                if metadata_response:\n                    results.append(SearchResult(\n                        image_id=hit.id,\n                        metadata=metadata_response[0].payload,\n                        score=hit.score\n                    ))\n            return results\n        except Exception as e:\n            print(f\"Error searching image in {model_name}: {e}\")\n            raise HTTPException(status_code=500, detail=f\"Error performing image search for model {model_name}\")\n\n    def index_image(self, image_base64: str, metadata: Dict[str, Any]) -> str:\n        try:\n            image_bytes = base64.b64decode(image_base64)\n            image = Image.open(io.BytesIO(image_bytes))\n            # Generate a deterministic UUID from the image content for the ID.\n            image_id = str(uuid.uuid5(uuid.NAMESPACE_DNS, image_base64))\n\n            # Store metadata first\n            self.client.upsert(\n                collection_name=IMAGE_COLLECTION_NAME,\n                points= [\n                    models.PointStruct(\n                        id=image_id,\n                        payload=metadata,\n                        vector={}\n                    )\n                ]\n            )\n\n            # Index image embeddings in each model's namespace\n            for model_name, config in MODEL_CONFIG.items():\n                collection_name = self._get_model_collection_name(model_name)\n                vector_dim = config[\"dim\"]\n                # Ensure collection exists, create if not (this should ideally be done during setup)\n                if not self.client.collection_exists(collection_name=collection_name):\n                    self.client.create_collection(\n                        collection_name=collection_name,\n                        vectors_config=models.VectorParams(size=vector_dim, distance=models.Distance.COSINE) # Assuming COSINE distance\n                    )\n                \n                query_vector = self._get_embedding(image, model_name)\n                \n                self.client.upsert(\n                    collection_name=collection_name,\n                    points= [\n                        models.PointStruct(\n                            id=image_id,\n                            vector=query_vector,\n                            payload=metadata # Payload can be repeated or just use image_id for lookup in metadata table\n                        )\n                    ]\n                )\n            return image_id\n        except Exception as e:\n            #print(f\"Error indexing image: {e}\")\n            raise #HTTPException(status_code=500, detail=f\"Error indexing image: {e}\")\n\n\n# --- Initialize Services ---\nqdrant_service = QdrantService(host=QDRANT_HOST, port=QDRANT_PORT)\n\n# --- API Endpoints ---\n\n@app.get(\"/models\", response_model=List[ModelInfo])\ndef get_models() -> List[ModelInfo]:\n    \"\"\"Gets a list of available models for benchmarking.\"\"\"\n    return qdrant_service.get_available_models()\n\n@app.post(\"/benchmark/text\", response_model=BenchmarkResponse)\ndef benchmark_text(request: TextBenchmarkRequest) -> BenchmarkResponse:\n    \"\"\"Runs a benchmark search using a text query.\"\"\"\n    start_time = time.time()\n    results = qdrant_service.search_by_text(request.query, request.model_name)\n    end_time = time.time()\n    latency_ms = (end_time - start_time) * 1000\n    return BenchmarkResponse(model_name=request.model_name, results=results, latency_ms=latency_ms)\n\n@app.post(\"/benchmark/image\", response_model=BenchmarkResponse)\ndef benchmark_image(request: ImageBenchmarkRequest) -> BenchmarkResponse:\n    \"\"\"Runs a benchmark search using an image.\"\"\"\n    start_time = time.time()\n    results = qdrant_service.search_by_image(request.image_base64, request.model_name)\n    end_time = time.time()\n    latency_ms = (end_time - start_time) * 1000\n    return BenchmarkResponse(model_name=request.model_name, results=results, latency_ms=latency_ms)\n\n@app.post(\"/index_image\", response_model=Dict[str, str])\ndef index_image(request: IndexImageRequest) -> Dict[str, str]:\n    \"\"\"Adds a new image to the index of each model.\"\"\"\n    image_id = qdrant_service.index_image(request.image_base64, request.metadata)\n    return {\"message\": \"Image indexed successfully\", \"image_id\": image_id}\n\n# --- Helper function to check and initialize collections (run once manually or via setup script) ---\n# This part is illustrative and would typically be handled by a setup script.\ndef initialize_collections():\n    # This function is intended to be run once to set up the necessary collections in Qdrant.\n    # It's not part of the API endpoints but crucial for the backend to function.\n    print(\"Initializing Qdrant collections...\")\n    try:\n        # Ensure metadata collection exists\n        if not qdrant_service.client.collection_exists(collection_name=IMAGE_COLLECTION_NAME):\n            qdrant_service.client.create_collection(\n                collection_name=IMAGE_COLLECTION_NAME,\n                vectors_config=models.VectorParams(size=1, distance=models.Distance.COSINE) # Dummy config for metadata-only\n            )\n            print(f\"Collection '{IMAGE_COLLECTION_NAME}' created.\")\n        else:\n            print(f\"Collection '{IMAGE_COLLECTION_NAME}' already exists.\")\n\n        # Ensure model-specific collections exist (based on potentially available models)\n        # This part is tricky without knowing the models beforehand. A better approach is to create them on demand or via a config.\n        # For demonstration, let's assume a few models might exist.\n        for model_name, config in MODEL_CONFIG.items():\n            collection_name = qdrant_service._get_model_collection_name(model_name)\n            vector_dim = config[\"dim\"]\n            if not qdrant_service.client.collection_exists(collection_name=collection_name):\n                qdrant_service.client.create_collection(\n                    collection_name=collection_name,\n                    vectors_config=models.VectorParams(size=vector_dim, distance=models.Distance.COSINE)\n                )\n                print(f\"Collection '{collection_name}' created for model '{model_name}'.\")\n            else:\n                print(f\"Collection '{collection_name}' already exists.\")\n\n    except Exception as e:\n        traceback.print_exc()\n        print(f\"Error during Qdrant initialization: {e}\")\n\n# Call initialization (e.g., when the server starts, or via a separate setup command)\n# initialize_collections()\n\n\nimport argparse\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Qdrant Service CLI\")\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Available commands\")\n\n    # Init command\n    init_parser = subparsers.add_parser(\"init\", help=\"Initialize Qdrant collections\")\n\n    # Models command\n    models_parser = subparsers.add_parser(\"models\", help=\"List available models\")\n\n    # Serve command\n    serve_parser = subparsers.add_parser(\"serve\", help=\"Start the FastAPI server\")\n    serve_parser.add_argument(\"--host\", default=\"0.0.0.0\", help=\"Host to run the server on\")\n    serve_parser.add_argument(\"--port\", type=int, default=8000, help=\"Port to run the server on\")\n\n    # Index command\n    index_parser = subparsers.add_parser(\"index\", help=\"Index an image\")\n    index_parser.add_argument(\"--image_path\", required=True, help=\"Path to the image file\")\n    index_parser.add_argument(\"--metadata\", required=True, help=\"JSON string of image metadata (e.g., '{\\\"url\\\": \\\"example.com/img.jpg\\\"}')\")\n\n    # Search text command\n    search_text_parser = subparsers.add_parser(\"search-text\", help=\"Search by text query\")\n    search_text_parser.add_argument(\"--query\", required=True, help=\"Text query string\")\n    search_text_parser.add_argument(\"--model\", required=True, help=\"Model name to use for search (e.g., ViT-B-32)\")\n    search_text_parser.add_argument(\"--limit\", type=int, default=10, help=\"Number of results to return\")\n\n    # Search image command\n    search_image_parser = subparsers.add_parser(\"search-image\", help=\"Search by image file\")\n    search_image_parser.add_argument(\"--image_path\", required=True, help=\"Path to the image file\")\n    search_image_parser.add_argument(\"--model\", required=True, help=\"Model name to use for search (e.g., ViT-B-32)\")\n    search_image_parser.add_argument(\"--limit\", type=int, default=10, help=\"Number of results to return\")\n\n    args = parser.parse_args()\n\n    if args.command == \"init\":\n        print(\"Running Qdrant collection initialization...\")\n        initialize_collections()\n        print(\"Initialization complete.\")\n    elif args.command == \"models\":\n        print(\"Available models:\")\n        models_list = qdrant_service.get_available_models()\n        for model in models_list:\n            print(f\"- {model.name}: {model.description} (dim: {model.dim})\")\n    elif args.command == \"index\":\n        try:\n            with open(args.image_path, \"rb\") as f:\n                image_bytes = f.read()\n            image_base64 = base64.b64encode(image_bytes).decode('utf-8')\n            import json\n            metadata = json.loads(args.metadata)\n            image_id = qdrant_service.index_image(image_base64, metadata)\n            print(f\"Image indexed successfully with ID: {image_id}\")\n        except Exception as e:\n            #print(f\"Error indexing image: {e}\")\n            raise\n    elif args.command == \"search-text\":\n        results = qdrant_service.search_by_text(args.query, args.model, args.limit)\n        print(f\"Search results: {results}\")\n    elif args.command == \"search-image\":\n        try:\n            with open(args.image_path, \"rb\") as f:\n                image_bytes = f.read()\n            image_base64 = base64.b64encode(image_bytes).decode('utf-8')\n            results = qdrant_service.search_by_image(image_base64, args.model, args.limit)\n            print(f\"Search results: {results}\")\n        except Exception as e:\n            print(f\"Error searching image: {e}\")\n    elif args.command == \"serve\":\n        import uvicorn\n        # To run this:\n        # 1. Ensure Qdrant is running on localhost:6333\n        # 2. Install dependencies: pip install fastapi uvicorn pydantic qdrant-client open-clip-torch Pillow\n        # 3. Run this script: python backend/main.py serve\n        # 4. Access API at http://127.0.0.1:8000\n        print(f\"Starting FastAPI server on {args.host}:{args.port}...\")\n        uvicorn.run(app, host=args.host, port=args.port)\n    else:\n        parser.print_help()\n\n\nif __name__ == \"__main__\":\n    main()\n"
}

--- Artifact '__1/__step_13_Kodax_result.txt' from (Engineer) in [T14]:
{"output":"Refined frontend components based on testing feedback (T13) and ensured all accessibility guidelines are met. Specifically, addressed issues identified in the tests and improved semantic HTML, ARIA attributes, and keyboard navigation where applicable. Integrated feedback from the Engineer's testing report to enhance component robustness and user experience.","artifact":{"task":"Refine the frontend based on testing feedback (T13) and ensure all accessibility guidelines are met.","files":[{"path":"frontend/src/components/SearchBar.jsx","content":"import React, { useState, useEffect, useRef } from 'react';\nimport { Form, Button, Dropdown, Alert } from 'react-bootstrap';\nimport * as api from '../services/api';\n\nfunction SearchBar({ onSearchResults, onError }) {\n  const [query, setQuery] = useState('');\n  const [selectedModel, setSelectedModel] = useState(null);\n  const [models, setModels] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showError, setShowError] = useState(false);\n\n  const dropdownRef = useRef(null);\n\n  useEffect(() => {\n    const fetchModels = async () => {\n      try {\n        const data = await api.fetchModels();\n        setModels(data);\n        // Set default model if available\n        if (data.length > 0) {\n          setSelectedModel(data[0]);\n        }\n      } catch (err) {\n        console.error(\"Failed to fetch models:\", err);\n        setError('Failed to load models. Please try again later.');\n        setShowError(true);\n      }\n    };\n    fetchModels();\n  }, []);\n\n  const handleSearch = async (event) => {\n    event.preventDefault();\n    if (!query.trim() || !selectedModel) {\n      setError('Please enter a search query and select a model.');\n      setShowError(true);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    setShowError(false);\n\n    try {\n      const results = await api.searchByText(query, selectedModel.name);\n      onSearchResults(results);\n    } catch (err) {\n      console.error(\"Search failed:\", err);\n      const errorMessage = err.message || 'Search failed. Please check your query and try again.';\n      setError(errorMessage);\n      setShowError(true);\n      onError(errorMessage); // Propagate error to parent\n      onSearchResults([]); // Clear previous results on error\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleModelSelect = (model) => {\n    setSelectedModel(model);\n    // Close dropdown manually after selection if needed, or rely on Bootstrap's behavior\n    if (dropdownRef.current) {\n      dropdownRef.current.classList.remove('show');\n      const menu = dropdownRef.current.querySelector('.dropdown-menu');\n      if (menu) menu.classList.remove('show');\n    }\n  };\n\n  // Handle closing dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {\n        // Close dropdown if it's open and click is outside\n        const menu = dropdownRef.current.querySelector('.dropdown-menu.show');\n        if (menu) {\n          dropdownRef.current.classList.remove('show');\n          menu.classList.remove('show');\n        }\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  const isSearchDisabled = !query.trim() || !selectedModel || isLoading;\n\n  return (\n    <Form onSubmit={handleSearch} className=\"mb-4 d-flex flex-column flex-md-row gap-2 align-items-center\">\n      <div className=\"flex-grow-1 w-100\">\n        <Form.Label htmlFor=\"search-query\" className=\"visually-hidden\">Search Query</Form.Label>\n        <Form.Control\n          id=\"search-query\"\n          type=\"text\"\n          placeholder=\"Enter your search query...\"\n          value={query}\n          onChange={(e) => {\n            setQuery(e.target.value);\n            if (showError) {\n              setShowError(false); // Hide error when user starts typing again\n            }\n          }}\n          aria-label=\"Search Query\"\n          aria-describedby=\"search-button search-model-button\"\n          className=\"w-100\"\n        />\n      </div>\n\n      <Dropdown className=\"w-100 w-md-auto\" ref={dropdownRef}>\n        <Dropdown.Toggle id=\"search-model-button\" variant=\"outline-secondary\" className=\"w-100\">\n          {selectedModel ? `${selectedModel.name} (${selectedModel.description})` : 'Select Model'}\n        </Dropdown.Toggle>\n        <Dropdown.Menu>\n          {models.map((model) => (\n            <Dropdown.Item\n              key={model.name}\n              onClick={() => handleModelSelect(model)}\n              active={selectedModel?.name === model.name}\n              href=\"#\"\n              role=\"option\"\n              aria-selected={selectedModel?.name === model.name}\n            >\n              {`${model.name} (${model.description})`}\n            </Dropdown.Item>\n          ))}\n        </Dropdown.Menu>\n      </Dropdown>\n\n      <Button\n        id=\"search-button\"\n        type=\"submit\"\n        variant=\"primary\"\n        disabled={isSearchDisabled}\n        aria-label=\"Search\"\n      >\n        {isLoading ? 'Searching...' : 'Search'}\n      </Button>\n      {showError && (\n        <Alert variant=\"danger\" className=\"w-100 mt-2\" dismissible onClose={() => setShowError(false)}>\n          {error}\n        </Alert>\n      )}\n    </Form>\n  );\n}\n\nexport default SearchBar;\n"},{"path":"frontend/src/components/ImageUploader.jsx","content":"import React, { useState, useEffect, useRef } from 'react';\nimport { Form, Button, Image, Alert, Dropdown } from 'react-bootstrap';\nimport * as api from '../services/api';\n\nfunction ImageUploader({ onImageIndexed }) {\n  const [selectedFile, setSelectedFile] = useState(null);\n  const [previewUrl, setPreviewUrl] = useState('');\n  const [metadata, setMetadata] = useState({ /* initial empty metadata fields */ });\n  const [models, setModels] = useState([]);\n  const [selectedModel, setSelectedModel] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [successMessage, setSuccessMessage] = useState('');\n  const [errorMessage, setErrorMessage] = useState('');\n  const [showError, setShowError] = useState(false);\n  const [showSuccess, setShowSuccess] = useState(false);\n\n  const fileInputRef = useRef(null);\n  const dropdownRef = useRef(null);\n\n  useEffect(() => {\n    const fetchModels = async () => {\n      try {\n        const data = await api.fetchModels();\n        setModels(data);\n        if (data.length > 0) {\n          setSelectedModel(data[0]);\n        }\n      } catch (err) {\n        console.error(\"Failed to fetch models:\", err);\n        setErrorMessage('Failed to load models. Please try again later.');\n        setShowError(true);\n      }\n    };\n    fetchModels();\n  }, []);\n\n  const handleFileChange = (event) => {\n    const file = event.target.files[0];\n    if (file) {\n      if (!file.type.startsWith('image/')) {\n        setErrorMessage('Invalid file type. Please select an image.');\n        setShowError(true);\n        setSelectedFile(null);\n        setPreviewUrl('');\n        return;\n      }\n      setSelectedFile(file);\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        setPreviewUrl(reader.result);\n        if (showError) {\n          setShowError(false); // Clear error if user selects a new file\n        }\n      };\n      reader.onerror = () => {\n        console.error(\"File read error:\", reader.error);\n        setErrorMessage('Error reading file.');\n        setShowError(true);\n        setSelectedFile(null);\n        setPreviewUrl('');\n      };\n      reader.readAsDataURL(file);\n      setSuccessMessage(''); // Clear previous success message\n      setShowSuccess(false);\n    }\n  };\n\n  const handleMetadataChange = (key, value) => {\n    setMetadata(prev => ({ ...prev, [key]: value }));\n  };\n\n  const handleAddMetadataField = () => {\n    // This is a placeholder. In a real app, you'd have input fields for keys and values.\n    // For now, let's assume metadata is handled externally or via a simple structure.\n    console.log(\"Add metadata field called\");\n  };\n\n  const handleIndexImage = async (event) => {\n    event.preventDefault();\n    if (!selectedFile || !selectedModel) {\n      setErrorMessage('Please select an image and choose a model.');\n      setShowError(true);\n      return;\n    }\n\n    setIsLoading(true);\n    setErrorMessage('');\n    setShowError(false);\n    setSuccessMessage('');\n    setShowSuccess(false);\n\n    try {\n      // Extract base64 string from previewUrl\n      const base64Image = previewUrl.split(',')[1];\n      const response = await api.indexImage(base64Image, metadata, selectedModel.name);\n      setSuccessMessage('Image indexed successfully!');\n      setShowSuccess(true);\n      onImageIndexed(response.image_id);\n      // Optionally clear form after successful indexing\n      setSelectedFile(null);\n      setPreviewUrl('');\n      setMetadata({});\n      if (fileInputRef.current) fileInputRef.current.value = '';\n    } catch (err) {\n      console.error(\"Image indexing failed:\", err);\n      const errorMessage = err.message || 'Image indexing failed. Please try again.';\n      setErrorMessage(errorMessage);\n      setShowError(true);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleModelSelect = (model) => {\n    setSelectedModel(model);\n    // Close dropdown\n    if (dropdownRef.current) {\n      dropdownRef.current.classList.remove('show');\n      const menu = dropdownRef.current.querySelector('.dropdown-menu');\n      if (menu) menu.classList.remove('show');\n    }\n  };\n\n  // Handle closing dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {\n        const menu = dropdownRef.current.querySelector('.dropdown-menu.show');\n        if (menu) {\n          dropdownRef.current.classList.remove('show');\n          menu.classList.remove('show');\n        }\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  const isIndexButtonDisabled = !selectedFile || !selectedModel || isLoading;\n\n  return (\n    <div className=\"card mb-4\">\n      <div className=\"card-body\">\n        <h5 className=\"card-title\">Index New Image</h5>\n        <Form onSubmit={handleIndexImage}>\n          <Form.Group className=\"mb-3\">\n            <Form.Label htmlFor=\"image-upload-input\">Choose Image</Form.Label>\n            <Form.Control\n              id=\"image-upload-input\"\n              type=\"file\"\n              accept=\"image/*\"\n              onChange={handleFileChange}\n              ref={fileInputRef}\n              aria-label=\"Choose Image file to upload\"\n            />\n          </Form.Group>\n\n          {previewUrl && (\n            <div className=\"mb-3 text-center\">\n              <Image src={previewUrl} alt=\"Preview\" style={{ maxWidth: '200px', maxHeight: '200px' }} rounded />\n            </div>\n          )}\n\n          {/* Simple Metadata Input Example */}\n          <div className=\"mb-3 d-flex gap-2\">\n            <Form.Control\n              type=\"text\"\n              placeholder=\"Metadata Key (e.g., url)\"\n              value={metadata.key || ''}\n              onChange={(e) => handleMetadataChange('key', e.target.value)}\n              aria-label=\"Metadata Key Input\"\n            />\n            <Form.Control\n              type=\"text\"\n              placeholder=\"Metadata Value\"\n              value={metadata.value || ''}\n              onChange={(e) => handleMetadataChange('value', e.target.value)}\n              aria-label=\"Metadata Value Input\"\n            />\n            <Button variant=\"secondary\" onClick={handleAddMetadataField} disabled={!metadata.key || !metadata.value}>\n              Add\n            </Button>\n          </div>\n          {/* Display added metadata (example) */}\n          {Object.keys(metadata).length > 2 && (\n            <div className=\"mb-3\">\n              <h6>Added Metadata:</h6>\n              <ul>\n                {Object.entries(metadata).map(([key, val]) => (\n                  <li key={key}>{key}: {val}</li>\n                ))}\n              </ul>\n            </div>\n          )}\n\n          <Dropdown className=\"mb-3 w-100\" ref={dropdownRef}>\n            <Dropdown.Toggle variant=\"outline-secondary\" className=\"w-100\">\n              {selectedModel ? `${selectedModel.name} (${selectedModel.description})` : 'Select Model'}\n            </Dropdown.Toggle>\n            <Dropdown.Menu>\n              {models.map((model) => (\n                <Dropdown.Item\n                  key={model.name}\n                  onClick={() => handleModelSelect(model)}\n                  active={selectedModel?.name === model.name}\n                  href=\"#\"\n                  role=\"option\"\n                  aria-selected={selectedModel?.name === model.name}\n                >\n                  {`${model.name} (${model.description})`}\n                </Dropdown.Item>\n              ))}\n            </Dropdown.Menu>\n          </Dropdown>\n\n          <Button\n            type=\"submit\"\n            variant=\"primary\"\n            disabled={isIndexButtonDisabled}\n            aria-label=\"Index Image\"\n          >\n            {isLoading ? 'Indexing...' : 'Index Image'}\n          </Button>\n        </Form>\n\n        {showSuccess && (\n          <Alert variant=\"success\" className=\"mt-3\">\n            {successMessage}\n          </Alert>\n        )}\n        {showError && (\n          <Alert variant=\"danger\" className=\"mt-3\" dismissible onClose={() => setShowError(false)}>\n            {errorMessage}\n          </Alert>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default ImageUploader;\n"},{"path":"frontend/src/components/SearchResults.jsx","content":"import React from 'react';\nimport { Card, Image, Alert, Row, Col } from 'react-bootstrap';\n\nfunction SearchResults({ results }) {\n  if (!results || results.length === 0) {\n    return null; // Don't render anything if there are no results\n  }\n\n  return (\n    <div className=\"mt-4\">\n      <h4>Search Results</h4>\n      <Row xs={1} sm={2} md={3} lg={4} className=\"g-4\">\n        {results.map((result) => (\n          <Col key={result.image_id}>\n            <Card className=\"h-100\">\n              <Card.Header>\n                <Card.Title as=\"h5\">{result.metadata.name || 'Unnamed Image'}</Card.Title>\n              </Card.Header>\n              <Card.Body>\n                {result.metadata.url ? (\n                  <Image \n                    src={result.metadata.url} \n                    alt={result.metadata.name || `Image ID: ${result.image_id}`}\n                    className=\"img-fluid mb-2 rounded\"\n                    aria-label={`Image preview for ${result.metadata.name || result.image_id}`}\n                  />\n                ) : (\n                  <div className=\"text-muted mb-2\">Image URL not available</div>\n                )}\n                <Card.Text>\n                  <strong>Score:</strong> {result.score.toFixed(4)}\n                </Card.Text>\n                {result.metadata.description && (\n                  <Card.Text>\n                    <strong>Description:</strong> {result.metadata.description}\n                  </Card.Text>\n                )}\n                {result.metadata.uploaded_by && (\n                  <Card.Text>\n                    <strong>Uploaded by:</strong> {result.metadata.uploaded_by}\n                  </Card.Text>\n                )}\n                {/* Render other metadata fields dynamically */}\n                {Object.entries(result.metadata).map(([key, value]) => {\n                  if (!['url', 'name', 'description', 'uploaded_by'].includes(key) && value) {\n                    return (\n                      <Card.Text key={key}>\n                        <strong>{key.charAt(0).toUpperCase() + key.slice(1)}:</strong> {value}\n                      </Card.Text>\n                    );\n                  }\n                  return null;\n                })}\n              </Card.Body>\n            </Card>\n          </Col>\n        ))}\n      </Row>\n    </div>\n  );\n}\n\nexport default SearchResults;\n"},{"path":"frontend/src/pages/SearchPage.jsx","content":"import React, { useState } from 'react';\nimport { Container, Row, Col, Alert } from 'react-bootstrap';\nimport SearchBar from '../components/SearchBar';\nimport ImageUploader from '../components/ImageUploader';\nimport SearchResults from '../components/SearchResults';\n\nfunction SearchPage() {\n  const [searchResults, setSearchResults] = useState([]);\n  const [indexingSuccess, setIndexingSuccess] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSearchResults = (results) => {\n    setSearchResults(results);\n    setIndexingSuccess(''); // Clear indexing success message when new search results appear\n    setError(''); // Clear any previous errors\n  };\n\n  const handleImageIndexed = (imageId) => {\n    setIndexingSuccess(`Image indexed successfully! (ID: ${imageId})`);\n    setSearchResults([]); // Clear search results after indexing\n    setError('');\n    // Optionally, auto-hide the success message after a few seconds\n    setTimeout(() => setIndexingSuccess(''), 5000);\n  };\n\n  const handleError = (errorMessage) => {\n    setError(errorMessage);\n    setIndexingSuccess(''); // Clear indexing success message on error\n    setSearchResults([]); // Clear search results on error\n  };\n\n  return (\n    <Container fluid className=\"p-3\">\n      <header className=\"mb-4 text-center\">\n        <h1 className=\"display-5\">Qdrant Image Search</h1>\n        <p className=\"text-muted\">Search images using text or upload your own.</p>\n      </header>\n\n      <Row>\n        <Col lg={6} className=\"mb-4 mb-lg-0\">\n          <SearchBar onSearchResults={handleSearchResults} onError={handleError} />\n          {searchResults.length > 0 && <SearchResults results={searchResults} />}\n        </Col>\n        <Col lg={6}>\n          <ImageUploader onImageIndexed={handleImageIndexed} onError={handleError} />\n        </Col>\n      </Row>\n\n      {indexingSuccess && (\n        <Alert variant=\"success\" className=\"mt-3\" dismissible onClose={() => setIndexingSuccess('')}>\n          {indexingSuccess}\n        </Alert>\n      )}\n      {error && (\n        <Alert variant=\"danger\" className=\"mt-3\" dismissible onClose={() => setError('')}>\n          {error}\n        </Alert>\n      )}\n    </Container>\n  );\n}\n\nexport default SearchPage;\n"},{"path":"frontend/src/App.jsx","content":"import React from 'react';\nimport { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\nimport SearchPage from './pages/SearchPage';\nimport './App.css'; // Ensure Bootstrap CSS is imported\nimport 'bootstrap/dist/css/bootstrap.min.css'; // Import Bootstrap CSS\n\nfunction App() {\n  return (\n    <Router>\n      <div className=\"App\">\n        <Routes>\n          <Route path=\"/\" element={<SearchPage />} />\n          {/* Add other routes here if needed */}\n        </Routes>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n"}]},"team":{"notes":"The Engineer has successfully refined the frontend components based on the testing feedback from T13. The changes focus on improving accessibility, error handling, and user experience, as evidenced in the updated code for `SearchBar.jsx`, `ImageUploader.jsx`, `SearchResults.jsx`, `SearchPage.jsx`, and `App.jsx`. The integration of Bootstrap 5 and adherence to responsive design principles are maintained. The next steps should involve deploying these changes and potentially gathering further user feedback.","prompts":[]},"reasoning":"The sub-task was to 'Refine the frontend based on testing feedback (T13) and ensure all accessibility guidelines are met.' The previous Engineer's output (T13) provided comprehensive test results for the core components. This execution focuses on addressing the implicit or explicit feedback from those tests and ensuring accessibility. \n\nKey refinements include:\n\n*   **`SearchBar.jsx`**: Added `aria-label` and `aria-describedby` for better accessibility, improved error handling display (`Alert`), ensured dropdowns are closable, and made the search button disabled appropriately. Added `role='option'` and `aria-selected` to dropdown items.\n*   **`ImageUploader.jsx`**: Added `aria-label` for file input and buttons, improved error/success message handling, ensured dropdowns are closable, and added `role='option'` and `aria-selected` to dropdown items. Added basic metadata key/value input for demonstration.\n*   **`SearchResults.jsx`**: Improved accessibility by adding `aria-label` to images and ensuring semantic HTML structure. Dynamically rendered metadata for better data presentation. Ensured it returns `null` for empty results.\n*   **`SearchPage.jsx`**: Consolidated error and success message handling. Ensured search results are cleared upon indexing and vice-versa. Added `dismissible` prop to `Alert` components for better user control.\n*   **`App.jsx`**: Ensured Bootstrap CSS is imported correctly and `BrowserRouter` is set up.\n\nThese changes directly address the need to refine the frontend based on testing feedback and enhance accessibility compliance by incorporating ARIA attributes, semantic HTML, and improved user feedback mechanisms."}



Please execute your sub-task, keeping the overall goal and your role's specific goal in mind to ensure your output is relevant to the project.