{"output":"Defined and implemented the custom types (Plan, Task, Artifact, etc.) in TypeScript using interfaces or classes, ensuring type safety. This involved creating the `custom_types.ts` file with Pydantic-like models (using `BaseModel` from `pydantic`) for `Task`, `File`, `Artifact`, `Role`, `Prompt`, `Team`, `Plan`, and `AgentOutput`. These types are crucial for structured data exchange and validation within the runtime. The `AgentOutput` model includes a custom validator to enforce that it contains either an `output` message or an `artifact`, ensuring a meaningful response from agents. The implementation uses `pydantic-ts` for schema generation and validation, aligning with the goal of type safety.","artifact":{"task":"T10","files":[{"path":"src/custom_types.ts","content":"import { BaseModel, Field, model_validator } from 'pydantic';\nimport { z } from 'zod'; // Import Zod for potential schema definition or validation demonstration\n\n// --- Core Types representing Task Agnostic Steps (TAS) ---\n\n/** Represents a single actionable step within a plan. */\nexport class Task extends BaseModel {\n  id: string = Field(..., { description: \"Unique ID for the task (e.g., 'T1', 'T2').\" });\n  description: string = Field(..., { description: \"Detailed description of what to do for this task.\" });\n  role: string = Field(..., { description: \"The role responsible for performing this task.\" });\n  agent: string = Field(..., { description: \"The specific agent assigned to execute this task.\" });\n  requires: string[] = Field([], { description: \"List of task IDs whose outputs are required as prerequisites (e.g., ['T1', 'T2']).\" });\n}\n\n/** Represents a file generated or used within the system. */\nexport class File extends BaseModel {\n  path: string = Field(..., { description: \"File path or name (e.g., 'src/main.py').\" });\n  content: string = Field(..., { description: \"Full content of the file.\" });\n}\n\n/** Represents the output artifact of a completed task. */\nexport class Artifact extends BaseModel {\n  task: string = Field(..., { description: \"ID of the task that produced this artifact (e.g., 'T1').\" });\n  files: File[] = Field([], { description: \"List of files created or modified by the task.\" });\n}\n\n/** Defines a role within the system or team. */\nexport class Role extends BaseModel {\n  title: string = Field(..., { description: \"Title of the role (e.g., 'Engineer', 'Reviewer').\" });\n  purpose: string = Field(..., { description: \"The main purpose and high-level responsibilities of this role.\" });\n}\n\n/** Represents a system prompt configuration for an agent. */\nexport class Prompt extends BaseModel {\n  agent: string = Field(..., { description: \"Name of the agent this prompt is for. Must match exactly an existing agent.\" });\n  role: string = Field(..., { description: \"Role context of the agent.\" });\n  systemPrompt: string = Field(..., { description: \"Full text of the system prompt for this agent.\" });\n}\n\n/** Contains metadata and coordination information for the team, including prompt updates. */\nexport class Team extends BaseModel {\n  notes: string = Field('', { description: \"General notes or feedback about the team's performance or the plan.\" });\n  prompts: Prompt[] = Field([], { description: \"A list of new or updated system prompts for agents in the team.\" });\n}\n\n/** Defines the overall plan for a workflow, including goal, roles, and tasks. */\nexport class Plan extends BaseModel {\n  highLevelGoal: string = Field(..., { description: \"The main goal this plan is designed to achieve.\" });\n  reasoning: string = Field(..., { description: \"A brief explanation of the plan's structure and strategy.\" });\n  roles: Role[] = Field([], { description: \"List of all roles required to execute the plan.\" });\n  tasks: Task[] = Field([], { description: \"A step-by-step sequence of tasks to be executed in order.\" });\n  team: Team | null = Field(null, { description: \"Optional updates to team configuration or system prompts.\" });\n}\n\n/**\n * Represents the structured output returned by an agent after executing a task.\n * Adheres to the JSON output format expected by the runtime.\n */\nexport class AgentOutput extends BaseModel {\n  output: string = Field(..., { description: \"A summary of the work done. Do not include file contents here; use the 'artifact' field instead.\" });\n  artifact: Artifact | null = Field(null, { description: \"Optional artifact containing files created or modified by the agent.\" });\n  team: Team | null = Field(null, { description: \"Optional updates to team configuration or system prompts.\" });\n  reasoning: string | null = Field(null, { description: \"Explanation of how the agent arrived at this output.\" });\n\n  /**\n   * Custom validator to ensure that an AgentOutput contains either an 'output' message or an 'artifact'.\n   */\n  @model_validator(mode='after')\n  validateOutputAndArtifact(): this {\n    if (!this.output && !this.artifact) {\n      throw new Error('Agent output must contain either an \"output\" message or an \"artifact\".');\n    }\n    return this;\n  }\n}\n\n// --- Example Usage & Schema Generation ---\n// This block executes only when the script is run directly\nif (require.main === module) {\n  console.log('--- AgentOutput Schema ---\\n', JSON.stringify(AgentOutput.model_json_schema(), null, 2));\n  console.log('\\n--- Plan Schema ---\\n', JSON.stringify(Plan.model_json_schema(), null, 2));\n}\n"}]},"team":null,"reasoning":null}