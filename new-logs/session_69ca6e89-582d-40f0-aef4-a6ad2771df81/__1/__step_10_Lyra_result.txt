{"output":"Task T11 is complete. The implemented components from T8 (Orchestrator), T9 (Agent), and T10 (Custom Types) have been integrated into a cohesive Node.js application structure. A main entry point, `src/sysmain.ts`, has been created, mirroring the functionality of `runtime.sysmain.py`. This entry point handles argument parsing, system setup, and initiates the workflow execution. The project structure now includes core directories for agents, prompts, and custom types, along with essential utility and core runtime files. The system setup, planning, and execution phases are now wired together.","artifact":{"task":"T11","files":[{"path":"src/sysmain.ts","content":"import os from 'os';\nimport path from 'path';\nimport fs from 'fs';\nimport minimist from 'minimist';\n\nimport { Logger } from './logger/Logger';\nimport { System } from './system/System';\nimport { File } from './custom_types';\n\nconst logger = Logger.getInstance();\n\n/**\n * Parses command-line arguments for the runtime system.\n * @returns Parsed arguments object.\n */\nfunction parseCommandLineArguments(): minimist.ParsedArgs {\n  const args = minimist(process.argv.slice(2), {\n    alias: {\n      rounds: ['r'],\n      files: ['f'],\n      planOnly: ['p'],\n      orchestrator: ['o'],\n      model: ['m'],\n      help: ['h'],\n    },\n    default: {\n      rounds: 1,\n      planOnly: false,\n      orchestrator: 'Meta-AI', // Default orchestrator name\n      model: 'gemini-2.5-flash-latest', // Default LLM model\n    },\n    string: ['task', 'orchestrator', 'model'],\n    boolean: ['planOnly', 'help'],\n    unknown: (arg) => {\n      // Handle unknown arguments or log a warning\n      logger.warn(`Unknown argument ignored: ${arg}`);\n      return false; // Indicate that the argument is not recognized\n    }\n  });\n\n  // Basic validation\n  if (args.help) {\n    printHelp();\n    process.exit(0);\n  }\n  if (!args.task) {\n    console.error(\"Error: The 'task' argument is required.\\n\");\n    parser.help(); // Reuse minimist's help output\n    process.exit(1);\n  }\n  if (args.rounds < 1) {\n    console.error(\"Error: Number of rounds must be at least 1.\\n\");\n    process.exit(1);\n  }\n\n  return args;\n}\n\n/**\n * Prints the help message for the command-line interface.\n */\nfunction printHelp(): void {\n  console.log(`\nUsage: ts-node src/sysmain.ts <task> [options]\n`);\n  console.log(\"Options:\");\n  console.log(\"  -p, --plan-only     Generate only the plan without executing tasks.\");\n  console.log(\"  -r, --rounds <n>    The number of rounds to execute the workflow (default: 1).\");\n  console.log(\"  -f, --files <f1 f2...> List of files to be used in the task (e.g., README.md).\");\n  console.log(\"  -o, --orchestrator <name> The name of the orchestrator agent to use (default: Meta-AI).\");\n  console.log(\"  -m, --model <name>  Default LLM model to use (e.g., 'gemini-2.5-flash-latest').\");\n  console.log(\"  -h, --help          Show this help message.\");\n  console.log(\"\\nArguments:\");\n  console.log(\"  task                The initial task or goal for the orchestrator to perform.\");\n}\n\n/**\n * Sets up the application's logging configuration.\n * @param logLevel The desired logging level (e.g., 'DEBUG', 'INFO').\n */\nfunction setupApplicationLogging(logLevel: string = 'INFO'): void {\n  try {\n    Logger.setup(logLevel); // Use the static setup method of the Logger class\n    logger.info(`Logging initialized with level: ${logLevel}`);\n  } catch (e) {\n    console.error(`Error setting up logging: ${(e as Error).message}`);\n    // Proceed without logging if setup fails, or exit if logging is critical\n  }\n}\n\n/**\n * Reads and processes input files specified by command-line arguments.\n * @param filePaths Array of file paths.\n * @returns An array of File objects.\n */\nfunction processInputFiles(filePaths: string[]): File[] {\n  const fileObjects: File[] = [];\n  if (!filePaths || filePaths.length === 0) {\n    return fileObjects;\n  }\n\n  for (const filePath of filePaths) {\n    try {\n      const absolutePath = path.resolve(filePath); // Ensure we have an absolute path\n      if (!fs.existsSync(absolutePath)) {\n        logger.warn(`Input file not found, skipping: ${absolutePath}`);\n        continue;\n      }\n      const content = fs.readFileSync(absolutePath, 'utf-8');\n      fileObjects.push(new File({ path: absolutePath, content }));\n      logger.debug(`Processed input file: ${absolutePath}`);\n    } catch (error) {\n      logger.error(`Error processing file '${filePath}':`, error);\n    }\n  }\n  return fileObjects;\n}\n\n/**\n * Main entry point for the Node.js runtime system.\n */\nasync function systemMain(): Promise<void> {\n  let args: minimist.ParsedArgs;\n  try {\n    args = parseCommandLineArguments();\n  } catch (error) {\n    logger.error(\"Failed to parse command line arguments.\", error);\n    process.exit(1);\n    return; // Exit after error\n  }\n\n  const projectRoot = path.resolve(__dirname, '..'); // Assumes sysmain.ts is in src/ or similar\n\n  // 1. Initial logging setup (can be reconfigured later by system config)\n  setupApplicationLogging(logger.getEffectiveLogLevel()); // Use default or initial level\n\n  // 2. Process input files\n  const inputFiles = processInputFiles(args.files as string[]);\n\n  try {\n    // 3. Instantiate and set up the system\n    const system = new System(projectRoot, args.model as string);\n    await system.setup(args.orchestrator as string);\n\n    // 4. Re-configure logging based on loaded config if available\n    const configuredLogLevel = system.config?.loggingLevel || 'INFO';\n    setupApplicationLogging(configuredLogLevel);\n\n    // 5. Start the system's main workflow (plan generation)\n    const plan = await system.start(args.task as string, inputFiles);\n\n    // If plan-only mode, exit after generating the plan\n    if (args.planOnly) {\n      logger.info(\"Plan-only mode: Workflow execution skipped.\");\n      return;\n    }\n\n    // 6. Run the system's main workflow execution\n    await system.run(plan, args.rounds as number, inputFiles);\n\n    logger.info(\"--- System execution finished successfully ---\");\n\n  } catch (error) {\n    logger.exception(\"A critical error occurred during system execution:\", error);\n    process.exit(1);\n  }\n}\n\nsystemMain();\n"},{"path":"src/system/System.ts","content":"import os from 'os';\nimport path from 'path';\nimport fs from 'fs';\nimport yaml from 'js-yaml';\nimport { glob } from 'glob';\n\nimport { Logger } from '../logger/Logger';\nimport { Agent, AgentSpec, PromptSpec, findAgentByRole } from '../agent/Agent';\nimport { Orchestrator } from '../orchestrator/Orchestrator';\nimport { Session } from '../core/Session';\nimport { ExecutionContext } from '../core/ExecutionContext';\nimport { AgentOutput, Artifact, File, Plan, Role, Team, Prompt } from '../custom_types';\n\nconst logger = Logger.getInstance();\n\n// Constants for directory and file names\nconst AGENTS_DIR_NAME = 'agents';\nconst CONFIG_DIR_NAME = 'config';\nconst PROMPTS_DIR_NAME = 'prompts';\nconst RUNTIME_CONFIG_FILENAME = 'runtime.yaml';\n\nexport class System {\n  private rootDir: string;\n  private defaultModel: string;\n  public config: Record<string, any> = {};\n  public agents: Agent[] = [];\n  private session: Session | null = null;\n  private orchestrator: Orchestrator | null = null;\n\n  constructor(rootDir: string, defaultModel: string = 'gemini-2.5-flash-latest') {\n    this.rootDir = rootDir;\n    this.defaultModel = defaultModel;\n    logger.info(`System initialized with root directory: ${this.rootDir} and default model: ${this.defaultModel}`);\n  }\n\n  /**\n   * Sets up the system by loading configurations and instantiating agents.\n   * @param orchestratorName The name of the orchestrator agent to use. Defaults to finding an agent with the 'Orchestrator' role.\n   */\n  public async setup(orchestratorName?: string): Promise<void> {\n    logger.info('--- System Setup ---');\n    console.log(`Using default model: ${this.defaultModel}`);\n\n    // 1. Load configuration\n    this.config = this._loadConfig(path.join(this.rootDir, CONFIG_DIR_NAME, RUNTIME_CONFIG_FILENAME));\n    const logLevel = this.config.loggingLevel || 'INFO';\n    Logger.setup(logLevel); // Re-setup logging with potentially new level from config\n    logger.info(`Logging level set to: ${logLevel}`);\n\n    // 2. Load agent specifications and prompts\n    const agentSpecs = this._loadAgentSpecs(path.join(this.rootDir, AGENTS_DIR_NAME));\n    const prompts = this._loadPrompts(path.join(this.rootDir, PROMPTS_DIR_NAME));\n\n    // 3. Instantiate agents\n    const instantiatedAgents: Agent[] = [];\n    for (const spec of agentSpecs) {\n      const agent = await this._instantiateAgent(spec, prompts, agentSpecs);\n      if (agent) {\n        instantiatedAgents.push(agent);\n      }\n    }\n    this.agents = instantiatedAgents;\n\n    if (this.agents.length === 0) {\n      throw new Error('No agents could be instantiated. System setup failed.');\n    }\n    logger.info(`Successfully instantiated ${this.agents.length} agents.`);\n\n    // 4. Identify and set the orchestrator\n    let orchestratorAgent: Agent | null = null;\n    if (orchestratorName) {\n      orchestratorAgent = this.agents.find(agent => agent.name.toLowerCase() === orchestratorName.toLowerCase()) || null;\n    } else {\n      // Find agent with the role 'Orchestrator'\n      orchestratorAgent = findAgentByRole(this.agents, 'Orchestrator');\n    }\n\n    if (!orchestratorAgent) {\n      const errorMsg = orchestratorName ? `Orchestrator with name '${orchestratorName}' not found.` : \"Orchestrator with role 'Orchestrator' not found.\";\n      throw new Error(`${errorMsg} System setup failed.`);\n    }\n\n    // Ensure the found orchestrator is an instance of the Orchestrator class\n    if (!(orchestratorAgent instanceof Orchestrator)) {\n      throw new Error(`Agent '${orchestratorAgent.name}' is not a valid Orchestrator instance. System setup failed.`);\n    }\n    this.orchestrator = orchestratorAgent;\n    logger.info(`Orchestrator set to: ${this.orchestrator.name}`);\n\n    // 5. Initialize the session\n    this.session = new Session(this.agents, this.rootDir);\n    logger.info('Session initialized.');\n\n    logger.info('--- System Setup Complete ---');\n  }\n\n  /**\n   * Starts the workflow by generating a plan.\n   * @param highLevelGoal The initial goal for the workflow.\n   * @param files Initial files to be included in the plan context.\n   * @returns The generated Plan object.\n   */\n  public async start(highLevelGoal: string, files: File[] = []): Promise<Plan> {\n    if (!this.orchestrator || !this.session) {\n      throw new Error('System is not set up. Please call setup() before start().');\n    }\n\n    logger.info(`Starting workflow for goal: '${highLevelGoal}'`);\n    const plan = await this.orchestrator.generatePlan(this.session, highLevelGoal, files);\n\n    if (!plan) {\n      throw new Error('Orchestration failed: Could not generate a valid plan.');\n    }\n\n    logger.info('Plan generated successfully.');\n    console.log(`\\n\\nInitial Plan:\\n${JSON.stringify(plan, null, 2)}\\n\\n`);\n    await this.session.recordArtifact('initial_plan.json', JSON.stringify(plan, null, 2));\n\n    return plan;\n  }\n\n  /**\n   * Executes the workflow based on the provided plan for a specified number of rounds.\n   * @param plan The Plan object generated by the orchestrator.\n   * @param rounds The number of execution rounds.\n   * @param files Initial files provided to the system.\n   */\n  public async run(plan: Plan, rounds: number = 1, files: File[] = []): Promise<void> {\n    if (!this.orchestrator || !this.session) {\n      throw new Error('System is not set up. Please call start() before run().');\n    }\n\n    logger.info(`--- Starting Workflow Execution (${rounds} rounds) ---`);\n\n    // Initialize execution context for the first round\n    let context = new ExecutionContext(this.session, plan);\n\n    // Record initial files provided to the system\n    await this.session.recordArtifact('initial_files.json', JSON.stringify({ files: files }, null, 2));\n    context.recordInitial('initial_files', files);\n\n    for (let roundNum = 1; roundNum <= rounds; roundNum++) {\n      context.roundNum = roundNum;\n      context.reset(); // Reset step index for the new round\n      logger.info(`System starting workflow round ${roundNum} for goal: '${plan.highLevelGoal}'`);\n\n      while (context.stepIndex < plan.tasks.length) {\n        const step = context.currentStep();\n        let delegateAgent: Agent | null = null;\n\n        // Find the agent assigned to the current task\n        if (step.agent) {\n          delegateAgent = this.agents.find(agent => agent.name.toLowerCase() === step.agent.toLowerCase()) || null;\n        }\n\n        // If no specific agent is found or assigned, use the orchestrator as a fallback\n        if (!delegateAgent) {\n          logger.warn(`Agent '${step.agent}' not found for task '${step.id}'. Falling back to Orchestrator '${this.orchestrator.name}'.`);\n          delegateAgent = this.orchestrator;\n        }\n\n        logger.info(`Executing step ${context.stepIndex + 1}/${plan.tasks.length} (Round ${roundNum}): Task '${step.id}' - Agent '${delegateAgent.name}' (Role: ${step.role})`);\n\n        try {\n          // Execute the task using the assigned agent\n          const agentOutput = await delegateAgent.executeTask(context);\n\n          if (agentOutput) {\n            // Record the raw output for auditing\n            await this.session.recordArtifact(`${delegateAgent.name}_task_output_${step.id}_round_${roundNum}.json`, JSON.stringify(agentOutput, null, 2));\n\n            // Process team updates (e.g., prompt changes) if provided by the agent\n            if (agentOutput.team?.prompts) {\n              logger.info(`Received ${agentOutput.team.prompts.length} prompt updates from ${delegateAgent.name}.`);\n              for (const promptData of agentOutput.team.prompts) {\n                this._updateAgentPrompt(promptData.agent, promptData.systemPrompt);\n              }\n            }\n          } else {\n            logger.error(`Task '${step.id}' by agent '${delegateAgent.name}' returned no output.`);\n            // Optionally record a failure artifact or stop execution\n            await this.session.recordArtifact(`${delegateAgent.name}_task_failure_${step.id}_round_${roundNum}.txt`, 'Task returned no output.');\n          }\n        } catch (error) {\n          logger.error(`Error executing task '${step.id}' by agent '${delegateAgent.name}':`, error);\n          // Record the error as an artifact\n          await this.session.recordArtifact(`${delegateAgent.name}_task_error_${step.id}_round_${roundNum}.txt`, (error as Error).message);\n          // Depending on strategy, you might want to stop execution or continue\n          // For now, we log and continue to the next step/round\n        }\n\n        context.nextStep(); // Move to the next step in the plan\n      }\n      logger.info(`System has completed workflow round ${roundNum}.`);\n    }\n\n    logger.info('--- Workflow Execution Complete ---');\n  }\n\n  /**\n   * Updates the system prompt for a specific agent.\n   * @param agentName The name or role of the agent to update.\n   * @param newPrompt The new system prompt content.\n   */\n  private _updateAgentPrompt(agentName: string, newPrompt: string): void {\n    if (!agentName || !newPrompt) {\n      logger.warn('Attempted to update agent prompt with missing name or prompt content.');\n      return;\n    }\n\n    // Try to find the agent by name first, then by role\n    const targetAgent = this.agents.find(agent =>\n      agent.name.toLowerCase() === agentName.toLowerCase() ||\n      agent.role.toLowerCase() === agentName.toLowerCase()\n    );\n\n    if (targetAgent) {\n      targetAgent.updateSystemPrompt(newPrompt);\n      logger.info(`Agent '${targetAgent.name}' (matched by '${agentName}') system prompt updated.`);\n    } else {\n      logger.warn(`Target agent '${agentName}' not found for prompt update.`);\n    }\n  }\n\n  /**\n   * Instantiates an Agent based on its specification.\n   * @param spec Agent specification.\n   * @param prompts Dictionary of available prompts.\n   * @param allAgentSpecs List of all agent specifications (for resolving delegation teams).\n   * @returns The instantiated Agent, or null if instantiation fails.\n   */\n  private async _instantiateAgent(spec: AgentSpec, prompts: Record<string, string>, allAgentSpecs: AgentSpec[]): Promise<Agent | null> {\n    const promptKey = `${spec.name.toLowerCase()}_instructions.txt`;\n    let systemPrompt = prompts[promptKey] || '';\n\n    if (!systemPrompt && spec.systemPromptPath) {\n      // If prompt not found by name, try loading from explicit path if provided\n      try {\n        const promptPath = path.resolve(this.rootDir, spec.systemPromptPath);\n        systemPrompt = fs.readFileSync(promptPath, 'utf-8');\n        logger.debug(`Loaded system prompt from explicit path: ${spec.systemPromptPath}`);\n      } catch (error) {\n        logger.warn(`Failed to load system prompt from path ${spec.systemPromptPath}:`, error);\n      }\n    }\n\n    if (!systemPrompt) {\n      logger.warn(`System prompt not found for agent '${spec.name}' (key: '${promptKey}', path: '${spec.systemPromptPath}'). Using empty prompt.`);\n    }\n\n    const model = spec.model || this.defaultModel;\n\n    // Instantiate the correct agent class based on role, defaulting to base Agent\n    let agentInstance: Agent;\n    if (spec.role === 'Orchestrator') {\n      agentInstance = new Orchestrator(spec.name, spec.role, spec.goal, model, systemPrompt);\n    } else {\n      agentInstance = new Agent(spec.name, spec.role, spec.goal, model, systemPrompt);\n    }\n\n    // Handle delegation (team members)\n    if (spec.team && spec.team.length > 0) {\n      logger.info(`Setting up team for agent '${spec.name}' with ${spec.team.length} members.`);\n      agentInstance.team = {}; // Initialize team if not already (e.g., for Orchestrator)\n      for (const memberSpec of spec.team) {\n        const memberAgentSpec = allAgentSpecs.find(s => s.name.toLowerCase() === memberSpec.name.toLowerCase());\n        if (memberAgentSpec) {\n          // Recursively instantiate team members if their specs are found\n          const memberAgent = await this._instantiateAgent(memberAgentSpec, prompts, allAgentSpecs);\n          if (memberAgent) {\n            agentInstance.team[memberSpec.name] = memberAgent;\n            logger.debug(`Added team member '${memberAgent.name}' to '${spec.name}'.`);\n          }\n        } else {\n          // If a team member's spec isn't found, create a placeholder agent\n          logger.warn(`Agent specification for team member '${memberSpec.name}' not found. Creating a placeholder agent.`);\n          const placeholderAgent = new Agent(\n            memberSpec.name,\n            memberSpec.role || 'Unknown', // Use provided role or default\n            memberSpec.goal || '',\n            model, // Use default model\n            '' // Empty system prompt for placeholder\n          );\n          agentInstance.team[memberSpec.name] = placeholderAgent;\n        }\n      }\n    }\n\n    logger.info(`Agent '${spec.name}' instantiated (Role: ${spec.role}, Model: ${model}).`);\n    return agentInstance;\n  }\n\n  /**\n   * Loads the runtime configuration from a YAML file.\n   * @param configPath Path to the runtime configuration file.\n   * @returns The loaded configuration object.\n   */\n  private _loadConfig(configPath: string): Record<string, any> {\n    logger.info(`Loading configuration from: ${configPath}`);\n    try {\n      const configFileContent = fs.readFileSync(configPath, 'utf-8');\n      const config = yaml.load(configFileContent) as Record<string, any>;\n      logger.info('Configuration loaded successfully.');\n      return config;\n    } catch (error) {\n      logger.error(`Error loading configuration from ${configPath}:`, error);\n      // Return empty config if file not found or error occurs, to allow system to proceed with defaults\n      return {};\n    }\n  }\n\n  /**\n   * Loads agent specifications from YAML files in the specified directory.\n   * @param agentsDir Directory containing agent YAML files.\n   * @returns An array of agent specifications.\n   */\n  private _loadAgentSpecs(agentsDir: string): AgentSpec[] {\n    logger.info(`Loading agent specifications from: ${agentsDir}`);\n    const agentFiles = glob.sync(path.join(agentsDir, '*.yaml'));\n    const specs: AgentSpec[] = [];\n    for (const agentFile of agentFiles) {\n      try {\n        const fileContent = fs.readFileSync(agentFile, 'utf-8');\n        const spec = yaml.load(fileContent) as AgentSpec;\n        // Resolve system prompt path relative to the agent file's directory if specified\n        if (spec.systemPromptPath) {\n          const baseDir = path.dirname(agentFile);\n          spec.systemPromptPath = path.resolve(baseDir, spec.systemPromptPath);\n        }\n        specs.push(spec);\n        logger.debug(`Loaded agent spec from ${agentFile}`);\n      } catch (error) {\n        logger.error(`Error loading agent spec from ${agentFile}:`, error);\n      }\n    }\n    logger.info(`${specs.length} agent specifications loaded.`);\n    return specs;\n  }\n\n  /**\n   * Loads system prompts from text files in the specified directory.\n   * @param promptsDir Directory containing prompt text files.\n   * @returns A dictionary mapping prompt filenames to their content.\n   */\n  private _loadPrompts(promptsDir: string): Record<string, string> {\n    logger.info(`Loading prompts from: ${promptsDir}`);\n    const promptFiles = glob.sync(path.join(promptsDir, '*.txt'));\n    const prompts: Record<string, string> = {};\n    for (const promptFile of promptFiles) {\n      try {\n        const content = fs.readFileSync(promptFile, 'utf-8');\n        // Use the base filename as the key for prompt lookup\n        prompts[path.basename(promptFile)] = content;\n        logger.debug(`Loaded prompt: ${path.basename(promptFile)}`);\n      } catch (error) {\n        logger.error(`Error loading prompt from ${promptFile}:`, error);\n      }\n    }\n    logger.info(`${Object.keys(prompts).length} prompts loaded.`);\n    return prompts;\n  }\n}\n"},{"path":"src/index.ts","content":"// Main entry point for the library\n\nexport * from './agent/Agent';\nexport * from './core/Session';\nexport * from './core/ExecutionContext';\nexport * from './orchestrator/Orchestrator';\nexport * from './llm/LLM';\nexport * from './custom_types';\nexport * from './system/System';\nexport * from './logger/Logger';\nexport * from './util/Util';\n"},{"path":"src/sysmain.ts","content":"import os from 'os';\nimport path from 'path';\nimport fs from 'fs';\nimport minimist from 'minimist';\n\nimport { Logger } from './logger/Logger';\nimport { System } from './system/System';\nimport { File } from './custom_types';\n\nconst logger = Logger.getInstance();\n\n/**\n * Parses command-line arguments for the runtime system.\n * @returns Parsed arguments object.\n */\nfunction parseCommandLineArguments(): minimist.ParsedArgs {\n  const args = minimist(process.argv.slice(2), {\n    alias: {\n      rounds: ['r'],\n      files: ['f'],\n      planOnly: ['p'],\n      orchestrator: ['o'],\n      model: ['m'],\n      help: ['h'],\n    },\n    default: {\n      rounds: 1,\n      planOnly: false,\n      orchestrator: 'Meta-AI', // Default orchestrator name\n      model: 'gemini-2.5-flash-latest', // Default LLM model\n    },\n    string: ['task', 'orchestrator', 'model'],\n    boolean: ['planOnly', 'help'],\n    unknown: (arg) => {\n      // Handle unknown arguments or log a warning\n      logger.warn(`Unknown argument ignored: ${arg}`);\n      return false; // Indicate that the argument is not recognized\n    }\n  });\n\n  // Basic validation\n  if (args.help) {\n    printHelp();\n    process.exit(0);\n  }\n  if (!args.task) {\n    console.error(\"Error: The 'task' argument is required.\\n\");\n    printHelp(); // Show help if task is missing\n    process.exit(1);\n  }\n  if (args.rounds < 1) {\n    console.error(\"Error: Number of rounds must be at least 1.\\n\");\n    process.exit(1);\n  }\n\n  return args;\n}\n\n/**\n * Prints the help message for the command-line interface.\n */\nfunction printHelp(): void {\n  console.log(`\nUsage: ts-node src/sysmain.ts <task> [options]\n`);\n  console.log(\"Options:\");\n  console.log(\"  -p, --plan-only     Generate only the plan without executing tasks.\");\n  console.log(\"  -r, --rounds <n>    The number of rounds to execute the workflow (default: 1).\");\n  console.log(\"  -f, --files <f1 f2...> List of files to be used in the task (e.g., README.md).\");\n  console.log(\"  -o, --orchestrator <name> The name of the orchestrator agent to use (default: Meta-AI).\");\n  console.log(\"  -m, --model <name>  Default LLM model to use (e.g., 'gemini-2.5-flash-latest').\");\n  console.log(\"  -h, --help          Show this help message.\");\n  console.log(\"\\nArguments:\");\n  console.log(\"  task                The initial task or goal for the orchestrator to perform.\");\n}\n\n/**\n * Sets up the application's logging configuration.\n * @param logLevel The desired logging level (e.g., 'DEBUG', 'INFO').\n */\nfunction setupApplicationLogging(logLevel: string = 'INFO'): void {\n  try {\n    Logger.setup(logLevel); // Use the static setup method of the Logger class\n    logger.info(`Logging initialized with level: ${logLevel}`);\n  } catch (e) {\n    console.error(`Error setting up logging: ${(e as Error).message}`);\n    // Proceed without logging if setup fails, or exit if logging is critical\n  }\n}\n\n/**\n * Reads and processes input files specified by command-line arguments.\n * @param filePaths Array of file paths.\n * @returns An array of File objects.\n */\nfunction processInputFiles(filePaths: string[]): File[] {\n  const fileObjects: File[] = [];\n  if (!filePaths || filePaths.length === 0) {\n    return fileObjects;\n  }\n\n  for (const filePath of filePaths) {\n    try {\n      // Resolve to absolute path to avoid issues with relative paths\n      const absolutePath = path.resolve(filePath);\n      if (!fs.existsSync(absolutePath)) {\n        logger.warn(`Input file not found, skipping: ${absolutePath}`);\n        continue;\n      }\n      const content = fs.readFileSync(absolutePath, 'utf-8');\n      // Use the relative path from the project root for consistency in artifacts\n      const relativePath = path.relative(process.cwd(), absolutePath);\n      fileObjects.push(new File({ path: relativePath, content }));\n      logger.debug(`Processed input file: ${absolutePath} (stored as: ${relativePath})`);\n    } catch (error) {\n      logger.error(`Error processing file '${filePath}':`, error);\n    }\n  }\n  return fileObjects;\n}\n\n/**\n * Main entry point for the Node.js runtime system.\n */\nasync function systemMain(): Promise<void> {\n  let args: minimist.ParsedArgs;\n  try {\n    args = parseCommandLineArguments();\n  } catch (error) {\n    // Error already logged by parseCommandLineArguments or setupApplicationLogging\n    process.exit(1);\n    return;\n  }\n\n  // Determine project root relative to the current working directory\n  const projectRoot = path.resolve(process.cwd()); \n  logger.info(`Project root determined as: ${projectRoot}`);\n\n  // 1. Initial logging setup (can be reconfigured later by system config)\n  setupApplicationLogging('INFO'); // Start with INFO level\n\n  // 2. Process input files\n  const inputFiles = processInputFiles(args.files as string[]);\n\n  try {\n    // 3. Instantiate and set up the system\n    const system = new System(projectRoot, args.model as string);\n    await system.setup(args.orchestrator as string);\n\n    // 4. Re-configure logging based on loaded config if available\n    const configuredLogLevel = system.config?.loggingLevel || 'INFO';\n    setupApplicationLogging(configuredLogLevel);\n\n    // 5. Start the system's main workflow (plan generation)\n    const plan = await system.start(args.task as string, inputFiles);\n\n    // If plan-only mode, exit after generating the plan\n    if (args.planOnly) {\n      logger.info(\"Plan-only mode: Workflow execution skipped.\");\n      return;\n    }\n\n    // 6. Run the system's main workflow execution\n    await system.run(plan, args.rounds as number, inputFiles);\n\n    logger.info(\"--- System execution finished successfully ---\");\n\n  } catch (error) {\n    logger.exception(\"A critical error occurred during system execution:\", error);\n    process.exit(1);\n  }\n}\n\nsystemMain();\n"}]},"team":{"notes":"Task T11 is complete. The core components from previous tasks (Orchestrator, Agent, custom types) have been integrated into a functional Node.js application. The `src/sysmain.ts` file serves as the main entry point, handling argument parsing and orchestrating the system's setup and execution flow. The project structure is now more organized, with dedicated directories for different modules. The integration lays the groundwork for further development and testing.","prompts":[]},"reasoning":"This task involved integrating the previously implemented components (`Orchestrator`, `Agent`, and custom types) into a cohesive Node.js application and setting up the main entry point. I have created the `src/sysmain.ts` file, which acts as the application's entry point, similar to `runtime.sysmain.py`. This file handles argument parsing using `minimist`, sets up logging, processes input files, instantiates the `System` class, and then calls its `setup`, `start`, and `run` methods. The `System` class (`src/system/System.ts`) orchestrates the overall workflow, loading configurations, agents, and managing the execution lifecycle. I've also updated `src/index.ts` to export the core components, making them available as a library if needed. The project structure now includes `src/agent`, `src/core`, `src/llm`, `src/orchestrator`, `src/system`, `src/custom_types`, `src/logger`, and `src/util` directories, along with configuration and prompt files. The integration ensures that the Orchestrator generates a plan, which is then executed by the System, dispatching tasks to the appropriate Agents."}