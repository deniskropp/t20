{"output":"The TypeScript runtime documentation has been generated, covering architecture, API, and usage instructions, analogous to the provided 'runtime.md'. This includes detailed explanations of core components like Agent, Session, ExecutionContext, Orchestrator, and LLM integration. The API reference provides method signatures and descriptions. Usage instructions cover installation and basic workflow execution. The documentation is structured for clarity and maintainability, reflecting the refactored and optimized TypeScript codebase.","artifact":{"task":"T15","files":[{"path":"runtime.md","content":"# Runtime Documentation (TypeScript Node.js)\n\n## Overview\n\nThis document provides comprehensive documentation for the TypeScript Node.js runtime system, detailing its components, core concepts, API, and usage. The design emphasizes clarity, maintainability, and adherence to State-Of-The-Art (SOTA) coding principles for Node.js and TypeScript.\n\n## Table of Contents\n\n*   [Introduction](#introduction)\n*   [Getting Started](#getting-started)\n*   [Core Concepts](#core-concepts)\n*   [API Reference](#api-reference)\n*   [Advanced Usage & Tutorials](#advanced-usage--tutorials)\n*   [Contribution Guide](#contribution-guide)\n*   [Troubleshooting & FAQ](#troubleshooting--faq)\n\n## Introduction\n\n### Overview of Runtime Components\n\nThe runtime system is designed to facilitate the execution of multi-agent workflows. Key components include:\n\n*   **`Agent`**: The base class for all agents, defining their lifecycle, task execution logic, and interaction patterns. Agents are the fundamental units that perform tasks within the system. Subclasses like `Orchestrator` provide specialized functionality.\n*   **`Session`**: Manages the overall state and artifacts of a workflow execution. It handles session IDs, artifact storage, and provides an interface for agents to interact with the system's state.\n*   **`ExecutionContext`**: Holds the context for a specific step or round within a workflow. It includes the plan, current step, and a collection of recorded artifacts from previous steps.\n*   **`Orchestrator`**: A specialized agent responsible for generating and managing the workflow plan. It interprets the high-level goal and breaks it down into a series of tasks for other agents.\n*   **`LLM`**: An abstract base class that abstracts LLM interactions. It provides a unified interface for various LLM providers (e.g., Gemini, Ollama, OpenAI, Mistral) and models, supporting a factory pattern for easy integration and interchangeability.\n*   **`Logger`**: A singleton class for centralized logging, supporting console and file output with customizable levels and formatting (including colored console output and JSONL).\n*   **`custom_types`**: Defines the Pydantic models used for structured data exchange, including `Plan`, `Task`, `File`, `Artifact`, `Prompt`, `Team`, and `AgentOutput`.\n\n## Getting Started\n\n### Installation\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd <repository-name>\n    ```\n\n2.  **Install dependencies:**\n    ```bash\n    npm install\n    ```\n\n3.  **Build the TypeScript project:**\n    ```bash\n    npm run build\n    ```\n\n### Basic Usage\n\nTo run a workflow, use the `main.ts` entry point. You need to provide an initial task description (which serves as the high-level goal) and optionally specify the number of rounds and input files.\n\n```bash\nnode dist/src/index.js \"Your initial task description\" -r 3 -f file1.txt file2.py\n```\n\n*   `\"Your initial task description\"`: The high-level goal for the workflow.\n*   `-r 3`: Specifies that the workflow should run for 3 rounds.\n*   `-f file1.txt file2.py`: Lists input files to be used during the task execution.\n\n## Core Concepts\n\n### Agents\n\nAgents are the core actors in the system. Each agent has a name, role, goal, and can be configured with a specific LLM model and system prompt. They execute tasks based on the provided context and plan. Agents can delegate tasks to sub-teams managed by the `Orchestrator` or other specialized agents.\n\n### Plans and Tasks\n\nA `Plan` is a structured definition of a workflow, comprising a sequence of `Task` objects. Each `Task` has an ID, a description, a responsible role, an assigned agent, and a list of prerequisite task IDs.\n\n### Artifacts\n\nArtifacts are outputs generated by agents during task execution. They can be stored and retrieved using the `Session` and `ExecutionContext` objects. The `ExecutionContext.recordArtifact` method is used to save artifacts for the current step, while `ExecutionContext.recordInitial` is used for initial inputs. Artifacts are stored within the session directory.\n\n### `AgentOutput` Model\n\nThe `AgentOutput` Pydantic model defines the structured response format for agents. It includes fields for the main `output` message, an optional `artifact` (containing files), and optional `team` updates (like new system prompts). This model ensures consistent communication between agents.\n\n### LLM Integration\n\nThe `LLM` class and its factory pattern allow for easy instantiation and usage of different LLM providers (Gemini, Ollama, OpenAI, Mistral) based on configuration. The `generateContent` method provides a unified interface for interacting with these models.\n\n## API Reference\n\n### `Agent` Class (`src/agent/Agent.ts`)\n\n*   **`constructor(name: string, role: string, goal: string, model: string, systemPrompt: string)`**: Initializes an agent instance.\n*   **`updateSystemPrompt(newPrompt: string): void`**: Updates the agent's system prompt.\n*   **`async executeTask(context: ExecutionContext): Promise<string | null>`**: Executes a task using the LLM based on the provided context. It prepares the prompt, including previous artifacts, and calls the LLM. Returns the agent's output as a JSON string or null on error.\n\n### `Orchestrator` Class (`src/orchestrator/Orchestrator.ts`)\n\n*   **`constructor(...)`**: Extends `Agent` constructor.\n*   **`async generatePlan(session: Session, highLevelGoal: string, files: File[]): Promise<Plan | null>`**: Generates a structured plan for the workflow.\n*   **`async executeTask(context: ExecutionContext): Promise<string | null>`**: Overrides base method to handle plan generation tasks.\n\n### `Session` Class (`src/core/Session.ts`)\n\n*   **`constructor(agents: Agent[], projectRoot: string)`**: Initializes a session with agents and project root.\n*   **`async addArtifact(name: string, content: any): Promise<void>`**: Saves an artifact in the session directory.\n*   **`async getArtifact(name: string): Promise<any | null>`**: Loads an artifact from the session directory.\n\n### `ExecutionContext` Class (`src/core/ExecutionContext.ts`)\n\n*   **`constructor(session: Session, plan: Plan, stepIndex?: number, roundNum?: number)`**: Initializes the execution context.\n*   **`nextStep(): void`**: Advances the step index.\n*   **`reset(): void`**: Resets the step index to 0.\n*   **`currentStep(): Task`**: Returns the current `Task` object.\n*   **`async recordArtifact(key: string, value: any, remember?: boolean): Promise<void>`**: Records an artifact for the current step and optionally remembers it in context memory.\n*   **`recordInitial(key: string, value: any): void`**: Records initial artifacts provided at the start of the workflow.\n*   **`getInitialFiles(): File[] | null`**: Retrieves initial files.\n\n### `LLM` Abstract Class (`src/llm/LLM.ts`)\n\n*   **`static factory(species: string): LLM`**: Factory method to create LLM instances (e.g., `Gemini`, `Olli`, `Opi`, `Mistral`).\n*   **`abstract async generateContent(...)`**: Abstract method for content generation.\n\n### `Logger` Class (`src/logger/Logger.ts`)\n\n*   **`static getInstance(): Logger`**: Gets the singleton logger instance.\n*   **`static setup(level: string): void`**: Configures logging level and handlers.\n*   **`info(message: string): void`**, **`warn(message: string): void`**, **`error(message: string): void`**, **`debug(message: string): void`**: Logging methods.\n\n### `custom_types` Module (`src/custom_types.ts`)\n\n*   **`Task`**: Represents a single actionable step in a plan.\n    *   `id`: Unique ID for the task.\n    *   `description`: What the task is and how to execute it.\n    *   `role`: Role responsible for performing this task.\n    *   `agent`: Specific agent assigned to this task.\n    *   `requires`: List of prerequisite task IDs.\n*   **`File`**: Represents a generated file.\n    *   `path`: File path or name.\n    *   `content`: Full content of the file.\n*   **`Artifact`**: Output artifact generated by a task.\n    *   `task`: ID of the task that produced this artifact.\n    *   `files`: List of `File` objects included in the artifact.\n*   **`Role`**: Definition of a role in the team.\n    *   `title`: Role title.\n    *   `purpose`: High-level responsibilities and objectives.\n*   **`Plan`**: Overall strategy with reasoning, roles, and tasks.\n    *   `highLevelGoal`: The overarching objective.\n    *   `reasoning`: Why this plan is structured this way.\n    *   `roles`: All roles needed for execution.\n    *   `tasks`: Step-by-step ordered tasks.\n    *   `team`: Optional `Team` updates.\n*   **`Prompt`**: System prompt assigned to an agent.\n    *   `agent`: Name of the agent this prompt is for.\n    *   `role`: Role context of the agent.\n    *   `systemPrompt`: Full text of the system prompt.\n*   **`Team`**: Metadata and coordination for the team.\n    *   `notes`: General notes, reflections, or feedback.\n    *   `prompts`: Updated system prompts for agents.\n*   **`AgentOutput`**: Structured output returned by an agent.\n    *   `output`: Message from the agent.\n    *   `artifact`: Optional `Artifact` generated by the agent.\n    *   `team`: Optional `Team` updates.\n    *   `reasoning`: Explanation of how the agent arrived at this output.\n\n## Advanced Usage & Tutorials\n\n### Advanced Planning\n\nThe planning process is primarily handled by the `Orchestrator` agent. To influence plan generation, you can:\n\n1.  **Refine the High-Level Goal:** A more specific and well-defined goal leads to a more effective plan.\n2.  **Engineer Prompts:** Modifying the system prompt for the `Orchestrator` (e.g., by adjusting files in the `prompts/` directory) can guide its reasoning and task decomposition. This allows for customization of how the orchestrator approaches planning, including task dependencies and role assignments.\n3.  **Provide Initial Files:** Including relevant context files during system startup can help the orchestrator create more informed plans.\n\n### LLM Configuration\n\nLLM providers and models are configured via `runtime.yaml`. The `LLM.factory` method uses the model identifier (e.g., `gemini-2.5-flash-latest`, `ollama:llama3`, `openai:gpt-4`) to instantiate the correct LLM client. Ensure necessary API keys and environment variables (e.g., `OPENAI_API_KEY`, `MISTRAL_API_KEY`) are set correctly.\n\n## Contribution Guide\n\n### Running Tests\n\nTo run the test suite, navigate to the project's root directory and execute:\n\n```bash\nnpm test\n```\n\nThis command will discover and run all tests defined within the project.\n\n## Troubleshooting & FAQ\n\n### How do I configure different LLM providers?\n\nLLM providers are configured within the `config/runtime.yaml` file. The `LLM.factory` method uses the model name to determine which provider to use (e.g., `gemini-`, `ollama:`, `openai:`, `mistral:` prefixes). Ensure that any necessary API keys or environment variables are set correctly before running the system.\n\n### What is the purpose of `runtime.md`?\n\nThis `runtime.md` file serves as the primary documentation for the runtime system. It's intended to be a user-friendly guide explaining the system's architecture, core concepts, API, and how to use and contribute to it. It is styled using a minimalist design aesthetic with a clean layout for optimal readability.\n"}]},"team":{"notes":"The documentation for the TypeScript runtime has been generated, covering architecture, API, and usage. This fulfills sub-task T15. The documentation is analogous to the original Python 'runtime.md' and reflects the refactored TypeScript codebase.","prompts":[]},"reasoning":"The primary goal of sub-task T15 was to document the new TypeScript runtime, including its architecture, API, and usage instructions, mirroring the structure of the provided 'runtime.md'. I have generated a new 'runtime.md' file that details the TypeScript components, their interactions, installation, and usage. This includes API references for key classes and modules, reflecting the refactored code. The documentation is now complete and ready for review."}