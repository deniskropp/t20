{
  "reasoning": "The user wants me to develop a configuration management strategy for the Python script. The input from the previous step (`integrated_script.py`) provides the core functionality of self-loading and service respawning. My task is to define how these services and their respawn parameters can be configured flexibly. This involves deciding on a configuration format (e.g., JSON, YAML, or Python dict), how the script will load this configuration, and how it will be used by the `ServiceManager`. I will propose using a JSON file for configuration due to its simplicity and widespread use in Python. The configuration will include service names, their execution commands, and respawn policies (like restart_policy, max_retries, retry_delay). The script will then be modified to load this JSON file at startup.",
  "output": "Developed a configuration management strategy using a JSON file (`services_config.json`) to define services and their respawn parameters. The `integrated_script.py` has been updated to load this configuration, making the service definitions flexible and easily manageable. This strategy allows users to add, remove, or modify services and their respawn behaviors without altering the core script logic.",
  "files": [
    {
      "name": "services_config.json",
      "content": "{\n  \"services\": [\n    {\n      \"name\": \"example_service_1\",\n      \"command\": \"python example_service_1.py\",\n      \"restart_policy\": \"always\",\n      \"max_retries\": 10,\n      \"retry_delay\": 5\n    },\n    {\n      \"name\": \"example_service_2\",\n      \"command\": \"python example_service_2.py\",\n      \"restart_policy\": \"on-failure\",\n      \"max_retries\": 5,\n      \"retry_delay\": 10\n    },\n    {\n      \"name\": \"failing_service_demo\",\n      \"command\": \"python failing_script.py\",\n      \"restart_policy\": \"on-failure\",\n      \"max_retries\": 3,\n      \"retry_delay\": 3\n    }\n  ]\n}"
    },
    {
      "name": "integrated_script.py",
      "content": "import importlib\nimport sys\nimport os\nimport time\nimport subprocess\nimport signal\nimport json\n\n# --- Service Manager Class (from Technical Expert's output) ---\nclass ServiceManager:\n    def __init__(self, service_configs):\n        self.service_configs = service_configs\n        self.processes = {}\n        self.running = True\n\n    def start_service(self, service_name):\n        config = self.service_configs[service_name]\n        command = config['command']\n        restart_policy = config.get('restart_policy', 'on-failure')\n        max_retries = config.get('max_retries', 5)\n        retry_delay = config.get('retry_delay', 5)\n\n        if service_name in self.processes and self.processes[service_name]['process'].poll() is None:\n            log(f\"Service {service_name} is already running.\")\n            return\n\n        try:\n            log(f\"Starting service: {service_name} with command: {command}\")\n            # Use Popen for non-blocking execution, create new process group for easier termination\n            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid) \n            self.processes[service_name] = {\n                'process': process,\n                'command': command,\n                'restart_policy': restart_policy,\n                'max_retries': max_retries,\n                'retry_delay': retry_delay,\n                'retries': 0,\n                'start_time': time.time()\n            }\n        except Exception as e:\n            log(f\"Error starting service {service_name}: {e}\")\n            # Handle initial start failure based on policy\n            if restart_policy != 'no' and self.processes[service_name]['retries'] < max_retries:\n                self.processes[service_name]['retries'] += 1\n                log(f\"Retrying service {service_name} in {retry_delay} seconds...\")\n                time.sleep(retry_delay)\n                self.start_service(service_name) # Recursive call for retry\n            else:\n                log(f\"Failed to start service {service_name} after {max_retries} retries.\")\n\n    def stop_service(self, service_name):\n        if service_name in self.processes:\n            process_info = self.processes[service_name]\n            process = process_info['process']\n            if process.poll() is None:  # If process is running\n                log(f\"Stopping service: {service_name}\")\n                try:\n                    # Send SIGTERM to the process group\n                    os.killpg(os.getpgid(process.pid), signal.SIGTERM)\n                    process.wait(timeout=5) # Wait for termination\n                    log(f\"Service {service_name} stopped.\")\n                except subprocess.TimeoutExpired:\n                    log(f\"Service {service_name} did not terminate gracefully, killing process group.\")\n                    os.killpg(os.getpgid(process.pid), signal.SIGKILL) # Send SIGKILL to the process group\n                    process.wait()\n                except ProcessLookupError:\n                    log(f\"Service {service_name} process already terminated.\")\n                except Exception as e:\n                    log(f\"Error stopping service {service_name}: {e}\")\n            del self.processes[service_name]\n\n    def monitor_services(self):\n        for service_name, process_info in list(self.processes.items()): # Use list to allow modification during iteration\n            process = process_info['process']\n            exit_code = process.poll() # Check if process has exited\n\n            if exit_code is not None: # Process has terminated\n                log(f\"Service {service_name} terminated with exit code: {exit_code}\")\n                process_info['retries'] += 1\n                restart_policy = process_info['restart_policy']\n                max_retries = process_info['max_retries']\n                retry_delay = process_info['retry_delay']\n\n                should_restart = False\n                if restart_policy == 'always':\n                    should_restart = True\n                elif restart_policy == 'on-failure' and exit_code != 0:\n                    should_restart = True\n                elif restart_policy == 'on-abnormal-exit' and exit_code not in [0, 1]: # Example: 0 is success, 1 might be controlled exit\n                    should_restart = True\n\n                if should_restart and process_info['retries'] <= max_retries:\n                    log(f\"Restarting service {service_name} (Attempt {process_info['retries']}/{max_retries}) in {retry_delay} seconds...\")\n                    time.sleep(retry_delay)\n                    self.start_service(service_name) # Restart the service\n                else:\n                    log(f\"Service {service_name} will not be restarted (Max retries reached or policy forbids).\")\n                    del self.processes[service_name] # Remove from monitoring if not restarting\n\n    def run_monitoring(self):\n        # Monitoring loop\n        while self.running:\n            self.monitor_services()\n            time.sleep(2) # Check every 2 seconds\n\n    def shutdown(self):\n        log(\"Initiating shutdown...\")\n        self.running = False\n        for service_name in list(self.processes.keys()):\n            self.stop_service(service_name)\n        log(\"All services stopped. Exiting.\")\n\n# --- Logging Utility (from self_loader.py) ---\ndef log(message):\n    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')\n    print(f\"[{timestamp}] {message}\")\n\n# --- Self-Loading and Respawning Logic (integrated from self_loader.py) ---\n\n# --- TAS: Define Orchestration Strategy (from T8)\n# Using ServiceManager for orchestration and os.execv for self-respawn.\n\n# --- TAS: Load Service Configurations (from T9)\n# Load configurations from a JSON file\ndef load_config(config_path='services_config.json'):\n    try:\n        with open(config_path, 'r') as f:\n            config_data = json.load(f)\n            # Convert list of services to a dictionary keyed by service name\n            services_dict = {svc['name']: svc for svc in config_data.get('services', [])}\n            log(f\"Configuration loaded successfully from {config_path}\")\n            return services_dict\n    except FileNotFoundError:\n        log(f\"Configuration file not found at {config_path}. Using default dummy services.\")\n        # Fallback to default dummy services if config file is missing\n        return {\n            \"example_service_1\": {\n                \"command\": f\"{sys.executable} example_service_1.py\",\n                \"restart_policy\": \"always\",\n                \"max_retries\": 10,\n                \"retry_delay\": 5\n            },\n            \"example_service_2\": {\n                \"command\": f\"{sys.executable} example_service_2.py\",\n                \"restart_policy\": \"on-failure\",\n                \"max_retries\": 5,\n                \"retry_delay\": 10\n            },\n            \"failing_service_demo\": {\n                \"command\": f\"{sys.executable} failing_script.py\",\n                \"restart_policy\": \"on-failure\",\n                \"max_retries\": 3,\n                \"retry_delay\": 3\n            }\n        }\n    except json.JSONDecodeError:\n        log(f\"Error decoding JSON from {config_path}. Using default dummy services.\")\n        # Fallback for invalid JSON\n        return {\n            \"example_service_1\": {\n                \"command\": f\"{sys.executable} example_service_1.py\",\n                \"restart_policy\": \"always\",\n                \"max_retries\": 10,\n                \"retry_delay\": 5\n            },\n            \"example_service_2\": {\n                \"command\": f\"{sys.executable} example_service_2.py\",\n                \"restart_policy\": \"on-failure\",\n                \"max_retries\": 5,\n                \"retry_delay\": 10\n            },\n            \"failing_service_demo\": {\n                \"command\": f\"{sys.executable} failing_script.py\",\n                \"restart_policy\": \"on-failure\",\n                \"max_retries\": 3,\n                \"retry_delay\": 3\n            }\n        }\n\n# --- TAS: Implement Respawn Policy (from T9)\ndef respawn_self(reason=\"\"): \n    log(f\"Initiating self-respawn. Reason: {reason}\")\n    log(f\"Current script: {sys.argv[0]}\")\n    log(f\"Arguments: {sys.argv[1:]}\")\n    \n    new_args = [sys.executable, os.path.abspath(__file__)]\n    new_args.append(\"--respawned\") \n    \n    log(f\"Executing: {' '.join(new_args)}\")\n    \n    try:\n        os.execv(sys.executable, new_args)\n    except OSError as e:\n        log(f\"Failed to respawn script: {e}\")\n        sys.exit(1)\n\n# --- TAS: Implement Graceful Shutdown (from T8 & T9) ---\ndef graceful_shutdown(service_manager=None):\n    log(\"Initiating graceful shutdown...\")\n    if service_manager:\n        service_manager.shutdown()\n    log(\"Main process shutting down.\")\n\n# --- Main Execution Logic ---\ndef main():\n    log(\"Script started.\")\n    \n    service_manager = None\n    \n    # Check if this is a respawned instance (optional, for demonstration)\n    if \"--respawned\" in sys.argv:\n        log(\"This is a respawned instance.\")\n        # Potentially adjust behavior for respawned instance\n\n    # --- Dynamic Loading and Service Management --- \n    # Load service configurations from JSON\n    service_configs = load_config()\n    \n    service_manager = ServiceManager(service_configs)\n    \n    # Start the service monitoring in a separate thread or process if needed for complex scenarios.\n    # For this example, we'll run it sequentially or manage its lifecycle.\n    # A common pattern is to fork or thread the monitoring loop.\n    # Here, we'll run it in the main thread after initial service starts.\n    \n    # Initial start of all services managed by ServiceManager\n    for service_name in service_configs:\n        service_manager.start_service(service_name)\n\n    # --- Handling Signals for Graceful Shutdown ---\n    def signal_handler(sig, frame):\n        graceful_shutdown(service_manager)\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, signal_handler) # Handle Ctrl+C\n    signal.signal(signal.SIGTERM, signal_handler) # Handle termination signal\n\n    # --- Main Loop: Keep script alive and monitor services ---\n    try:\n        # TAS: Manage Service Lifecycle (through start_service and monitor_services)\n        # TAS: Monitor Service Status (within monitor_services)\n        # TAS: Implement Respawn Policy (within monitor_services)\n        # TAS: Handle Process Errors (implicitly via subprocess and try-except blocks)\n        # TAS: Implement Graceful Shutdown (via signal_handler and manager.shutdown())\n        service_manager.run_monitoring()\n        \n    except Exception as e:\n        log(f\"An unexpected error occurred in the main loop: {e}\")\n        graceful_shutdown(service_manager)\n        # Optionally, trigger a self-respawn on critical errors\n        respawn_self(f\"Critical error in main loop: {e}\")\n\nif __name__ == \"__main__\":\n    # --- Create dummy service files for demonstration if they don't exist ---\n    if not os.path.exists(\"example_service_1.py\"):\n        with open(\"example_service_1.py\", \"w\") as f:\n            f.write(\"import time\\nimport sys\\nimport os\\n\\ndef run():\\n    print('[Service 1] Running...')\\n    # Simulate a process that might fail randomly\\n    fail_chance = 0.1 # 10% chance of failure\\n    counter = 0\\n    while True:\\n        print(f'[Service 1] Heartbeat... (counter: {counter})')\\n        time.sleep(2)\\n        counter += 1\\n        if os.environ.get('FAIL_SERVICE_1') == 'true' and counter % 5 == 0: # Example condition to fail\\n             print('[Service 1] Simulating failure!')\\n             sys.exit(1)\\n\\ndef stop():\\n    print('[Service 1] Stopping gracefully...')\\n\")\n\n    if not os.path.exists(\"example_service_2.py\"):\n        with open(\"example_service_2.py\", \"w\") as f:\n            f.write(\"import time\\n\\ndef run():\\n    print('[Service 2] Running...')\\n    while True:\\n        print('[Service 2] Working...')\\n        time.sleep(3)\\n\\ndef stop():\\n    print('[Service 2] Stopping gracefully...')\\n\")\n\n    if not os.path.exists(\"failing_script.py\"):\n        with open(\"failing_script.py\", \"w\") as f:\n            f.write(\"import time\\nimport sys\\n\\nprint('[Failing Script] Starting up...')\\ntime.sleep(1)\\nprint('[Failing Script] Exiting with error code 1...')\\nsys.exit(1)\\n\")\n\n    main()\n"
    }
  ]
}