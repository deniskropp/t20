The overall goal is: 'Python Script that loads itself and respawns services'

Your role's specific goal is: 'Structure workflows and ensure clarity in agent instructions, system prompt engineering'
Your specific sub-task is: 'Define the prompt engineering strategy for guiding the development of the Python script, focusing on clarity and effectiveness for AI agents.'

The team's roles are:
    {'reasoning': 'The goal is to create a Python script that can load itself and respawn services. This requires a systematic approach, starting with understanding the core requirements, designing the system architecture, implementing the script, and ensuring its reliability through testing and refinement. The roles provided are diverse, and their tasks should reflect a logical progression from conceptualization to execution and maintenance. The plan is structured to first define the problem and requirements, then design the solution, followed by implementation, and finally, testing and iteration. Prompt engineering is integrated to refine agent instructions at each stage.', 'roles': [{'title': 'System Architect', 'description': 'Designs the overall structure and components of the system.'}, {'title': 'Requirements Analyst', 'description': 'Gathers and analyzes the functional and non-functional requirements of the system.'}, {'title': 'Technical Expert', 'description': 'Provides in-depth knowledge on specific technologies and implementation details.'}, {'title': 'Conceptual Analyst', 'description': 'Analyzes and refines the core concepts and logic of the system.'}, {'title': 'Researcher', 'description': 'Investigates existing solutions, libraries, and best practices.'}, {'title': 'Linguistic Mapper', 'description': 'Ensures clear and consistent communication and terminology within the project.'}, {'title': 'Lexicographer', 'description': 'Defines and standardizes the vocabulary used in the project.'}, {'title': 'Theoretical Liaison', 'description': 'Bridges theoretical concepts with practical implementation.'}, {'title': 'Relevance Assessor', 'description': 'Evaluates the relevance and applicability of proposed solutions and ideas.'}, {'title': 'Contextual Analyst', 'description': 'Analyzes the operational context and constraints of the system.'}, {'title': 'System Integrator', 'description': 'Oversees the integration of different system components.'}, {'title': 'Metrics Designer', 'description': 'Defines metrics for evaluating system performance and success.'}, {'title': 'Quality Assurance Specialist', 'description': 'Develops and executes test plans to ensure system quality.'}, {'title': 'Theoretical Advisor', 'description': 'Provides guidance on theoretical underpinnings and advanced concepts.'}, {'title': 'Feedback System', 'description': 'Designs and manages mechanisms for collecting and processing feedback.'}, {'title': 'Data Engineer', 'description': 'Handles data-related aspects, if any, in the system.'}, {'title': 'UX Researcher', 'description': "Focuses on user experience, if applicable to the script's interaction."}, {'title': 'Ingestion Specialist', 'description': 'Manages the process of bringing in necessary resources or data.'}, {'title': 'Data Validator', 'description': 'Ensures the integrity and correctness of data.'}, {'title': 'Source Integrator', 'description': 'Integrates with external data sources or services.'}, {'title': 'Theoretical Analyst', 'description': 'Analyzes theoretical aspects relevant to the project.'}, {'title': 'Pattern Recognizer', 'description': 'Identifies patterns in data or behavior for optimization.'}, {'title': 'Insight Extractor', 'description': 'Derives actionable insights from analysis.'}, {'title': 'Response Generator', 'description': 'Formulates responses or outputs based on analysis.'}, {'title': 'Theoretical Content Curator', 'description': 'Manages and organizes theoretical knowledge relevant to the project.'}, {'title': 'Context Synthesizer', 'description': 'Synthesizes information from various contexts.'}, {'title': 'Feedback Processor', 'description': 'Processes and categorizes feedback received.'}, {'title': 'Theoretical Evaluator', 'description': 'Evaluates theoretical models and approaches.'}, {'title': 'Improvement Analyst', 'description': 'Analyzes areas for improvement in the system or process.'}, {'title': 'Refinement Strategist', 'description': 'Develops strategies for refining the system.'}, {'title': 'Model Tuner', 'description': 'Adjusts parameters for optimal performance.'}, {'title': 'Workflow Designer', 'description': 'Designs and optimizes the workflow for development and execution.'}, {'title': 'Configuration Manager', 'description': 'Manages system configurations and settings.'}, {'title': 'Prompt Engineer', 'description': 'Structures workflows and ensures clarity in agent instructions, system prompt engineering.'}, {'title': 'Task-Agnostic Step Extractor', 'description': "Identifies and extracts each 'Task Agnostic Step' (TAS) towards the high-level goal."}], 'tasks': [{'task_id': 'T1', 'task': 'Define the core requirements for a Python script that can load itself and respawn services. This includes identifying essential functionalities, potential challenges, and desired outcomes.', 'role': 'Requirements Analyst', 'name': 'LaReqAnalyst', 'requires': []}, {'task_id': 'T2', 'task': 'Research existing Python libraries and techniques for self-loading scripts and service management (e.g., `importlib`, `subprocess`, systemd, supervisor).', 'role': 'Researcher', 'name': 'LaResearcher', 'requires': []}, {'task_id': 'T3', 'task': 'Analyze the theoretical underpinnings of self-modifying code and dynamic service management to ensure a robust and secure approach.', 'role': 'Theoretical Analyst', 'name': 'LaTheolAna', 'requires': []}, {'task_id': 'T4', 'task': 'Based on requirements and research, propose a high-level system architecture for the Python script, outlining key components and their interactions.', 'role': 'System Architect', 'name': 'LaSysDesigner', 'requires': ['T1', 'T2']}, {'task_id': 'T5', 'task': 'Refine the system architecture and conceptual design, ensuring logical consistency and feasibility.', 'role': 'Conceptual Analyst', 'name': 'LaConceptAna', 'requires': ['T4']}, {'task_id': 'T6', 'task': "Develop a detailed plan for the Python script's implementation, including module breakdown, data structures, and control flow.", 'role': 'Workflow Designer', 'name': 'LaWorkflowDes', 'requires': ['T5']}, {'task_id': 'T7', 'task': 'Define the prompt engineering strategy for guiding the development of the Python script, focusing on clarity and effectiveness for AI agents.', 'role': 'Prompt Engineer', 'name': 'Lyra', 'requires': ['T6']}, {'task_id': 'T8', 'task': 'Extract Task-Agnostic Steps (TAS) from the refined requirements and conceptual design to guide the implementation.', 'role': 'Task-Agnostic Step Extractor', 'name': 'TASe', 'requires': ['T5']}, {'task_id': 'T9', 'task': 'Extract Task-Agnostic Steps (TAS) from the detailed implementation plan.', 'role': 'Task-Agnostic Step Extractor', 'name': 'uTASe', 'requires': ['T6']}, {'task_id': 'T10', 'task': 'Extract Task-Agnostic Steps (TAS) from the prompt engineering strategy.', 'role': 'Task-Agnostic Step Extractor', 'name': 'GPTASe', 'requires': ['T7']}, {'task_id': 'T11', 'task': 'Implement the core logic for the Python script to load itself, potentially using dynamic import mechanisms.', 'role': 'System Integrator', 'name': 'LaSysIntegrator', 'requires': ['T8', 'T9']}, {'task_id': 'T12', 'task': 'Implement the service respawning functionality within the Python script, considering different service management approaches.', 'role': 'Technical Expert', 'name': 'LaTheoExpert', 'requires': ['T8', 'T9']}, {'task_id': 'T13', 'task': 'Integrate the self-loading and service respawning components, ensuring seamless operation.', 'role': 'System Integrator', 'name': 'LaSysIntegrator', 'requires': ['T11', 'T12']}, {'task_id': 'T14', 'task': 'Develop a configuration management strategy for the script, allowing for flexible service definitions and respawn parameters.', 'role': 'Configuration Manager', 'name': 'LaConfigMgr', 'requires': ['T13']}, {'task_id': 'T15', 'task': "Define metrics for evaluating the script's performance, reliability, and resource usage.", 'role': 'Metrics Designer', 'name': 'LaMetricsDes', 'requires': ['T1']}, {'task_id': 'T16', 'task': 'Create a comprehensive test plan, including unit tests, integration tests, and stress tests for the script.', 'role': 'Quality Assurance Specialist', 'name': 'LaQASpecialist', 'requires': ['T13', 'T15']}, {'task_id': 'T17', 'task': 'Execute the test plan and document any bugs or performance issues.', 'role': 'Quality Assurance Specialist', 'name': 'LaQASpecialist', 'requires': ['T16']}, {'task_id': 'T18', 'task': "Analyze test results and identify areas for improvement in the script's logic, efficiency, or robustness.", 'role': 'Improvement Analyst', 'name': 'LaImproveAna', 'requires': ['T17']}, {'task_id': 'T19', 'task': 'Refine the script based on feedback from testing and analysis, iterating on the implementation.', 'role': 'Refinement Strategist', 'name': 'LaRefineStrat', 'requires': ['T18']}, {'task_id': 'T20', 'task': 'Document the Python script, including its functionality, usage, configuration, and maintenance procedures.', 'role': 'Linguistic Mapper', 'name': 'LaLingMapper', 'requires': ['T19']}, {'task_id': 'T21', 'task': 'Establish a feedback loop for ongoing monitoring and improvement of the script.', 'role': 'Feedback System', 'name': 'LaFeedbackSys', 'requires': ['T20']}, {'task_id': 'T22', 'task': 'Review and refine the prompt engineering strategy based on the development process and outcomes.', 'role': 'Prompt Engineer', 'name': 'Lyra', 'requires': ['T19', 'T21']}]}

Please use the following outputs from the other agents as your input:

Artifact from 1__step_5_LaWorkflowDes_result.txt (Workflow Designer)[T6]:
{
  "reasoning": "The user wants a detailed plan for the Python script's implementation. This plan should cover module breakdown, data structures, and control flow. I have received input from the Conceptual Analyst (T5) which refines the architecture and core concepts. My task (T6) is to build upon this refined design to create the implementation plan. I will structure the plan logically, detailing the necessary modules, how data will be represented and managed (data structures), and the sequence of operations (control flow).",
  "output": "## Detailed Implementation Plan for Python Service Orchestrator\n\nThis document outlines the implementation plan for the Python script responsible for managing and respawning services, building upon the refined conceptual design.\n\n**1. Module Breakdown:**\n\nThe script will be modularized to promote reusability, testability, and maintainability. Key modules include:\n\n*   **`main.py` (Orchestrator Core):**\n    *   Entry point of the script.\n    *   Initializes logging, configuration, and service manager.\n    *   Contains the main control loop for monitoring services.\n    *   Handles signal processing for graceful shutdown.\n    *   Manages the lifecycle of the Orchestrator itself (e.g., initiating self-restart if designed).\n\n*   **`config_manager.py`:**\n    *   Loads and validates service configurations from a specified file (e.g., JSON, YAML).\n    *   Provides methods to access service configurations (command, restart policy, dependencies, etc.).\n    *   Handles potential configuration file errors.\n\n*   **`service_manager.py`:**\n    *   Manages individual service processes.\n    *   `start_service(service_config)`: Uses `subprocess.Popen` to launch a service.\n    *   `stop_service(service_name)`: Sends SIGTERM to a service process.\n    *   `restart_service(service_name)`: Stops and then starts a service.\n    *   `get_service_status(service_name)`: Checks if a process is running using `Popen.poll()` or `psutil`.\n    *   Maintains a registry of running service Popen objects and their states.\n\n*   **`monitor.py`:**\n    *   Contains the logic for the main monitoring loop.\n    *   Periodically checks the status of all managed services.\n    *   Detects unexpected service terminations.\n    *   Triggers respawn actions via the `service_manager` based on defined policies.\n    *   May incorporate dependency checking before respawning.\n\n*   **`logger_config.py`:**\n    *   Sets up the logging configuration (format, level, output handlers - e.g., file, console).\n    *   Ensures consistent logging across all modules.\n\n*   **`utils.py` (Optional):**\n    *   Helper functions, e.g., for path manipulation, argument parsing, or specific OS interactions.\n\n**2. Data Structures:**\n\n*   **Service Configuration:** A dictionary or list of dictionaries, loaded from the configuration file. Each service entry should contain:\n    *   `name`: Unique identifier for the service.\n    *   `command`: The command to execute (list of strings).\n    *   `working_dir`: Optional working directory.\n    *   `environment`: Optional environment variables.\n    *   `restart_policy`: (e.g., `always`, `on-failure`, `never`).\n    *   `max_retries`: Maximum respawn attempts within a time window.\n    *   `retry_delay`: Initial delay before first retry.\n    *   `dependencies`: List of service names that must be running before this service starts.\n    *   `timeout_start`: Maximum time to wait for service to start.\n    *   `timeout_stop`: Maximum time to wait for service to stop.\n\n*   **Service State Registry:** A dictionary within `service_manager.py` to track the state of each managed service:\n    *   Key: `service_name`\n    *   Value: A dictionary containing:\n        *   `process`: The `subprocess.Popen` object.\n        *   `status`: (e.g., `PENDING`, `STARTING`, `RUNNING`, `STOPPING`, `STOPPED`, `FAILED`, `RESTARTING`).\n        *   `pid`: Process ID.\n        *   `start_time`: Timestamp of last successful start.\n        *   `retry_count`: Current number of respawn attempts.\n        *   `last_exit_code`: Exit code of the last termination.\n\n*   **Global State:** Potentially a small object or dictionary in `main.py` to hold global settings or flags (e.g., `is_shutting_down`).\n\n**3. Control Flow:**\n\n*   **Initialization:**\n    1.  `main.py` starts.\n    2.  `logger_config.py` initializes logging.\n    3.  `config_manager.py` loads and validates the service configuration file.\n    4.  `service_manager.py` initializes its internal state registry (empty).\n    5.  `monitor.py` is initialized.\n    6.  Orchestrator registers itself with its own supervisor (if applicable).\n\n*   **Service Startup Sequence:**\n    1.  The Orchestrator (in `main.py` or `monitor.py`) iterates through the loaded service configurations.\n    2.  For each service, it checks dependencies. If dependencies are not met, it waits and retries.\n    3.  Once dependencies are met (or if none exist), it calls `service_manager.start_service()`.\n    4.  `start_service` uses `subprocess.Popen`, captures the `Popen` object, updates the state registry to `STARTING`, and potentially logs the start event.\n    5.  The initial status check might confirm if it's `RUNNING` or immediately `FAILED`.\n\n*   **Monitoring Loop (in `monitor.py`):**\n    1.  Runs periodically (e.g., every 5-10 seconds).\n    2.  Iterates through the `service_state_registry` in `service_manager.py`.\n    3.  For each `RUNNING` service:\n        *   Check `process.poll()`.\n        *   If `poll()` returns an exit code (process terminated):\n            *   Record the exit code and update status to `FAILED` or `STOPPED`.\n            *   Evaluate `restart_policy`.\n            *   If restart is required and `max_retries` not exceeded, schedule a restart (potentially with a delay).\n            *   Call `service_manager.restart_service()`.\n    4.  For services marked for restart:\n        *   Perform dependency checks.\n        *   Call `service_manager.restart_service()` which calls `stop_service` then `start_service`.\n    5.  Handle new services added dynamically (if supported).\n    6.  Log any status changes or detected issues.\n\n*   **Graceful Shutdown (Signal Handling in `main.py`):**\n    1.  Catch SIGINT/SIGTERM signals.\n    2.  Set a global flag `is_shutting_down = True`.\n    3.  Iterate through all managed services in the `service_state_registry`.\n    4.  For each running service, call `service_manager.stop_service()`.\n    5.  `stop_service` sends SIGTERM to the `Popen` object and waits for a defined `timeout_stop`.\n    6.  If a service doesn't stop within the timeout, send SIGKILL.\n    7.  Once all managed services are stopped, the Orchestrator exits.\n\n*   **Self-Restart/Reload (Advanced - Optional):**\n    *   If the script needs to reload its own code or restart itself:\n        *   Use `os.exec*` to replace the current process with a new instance, passing necessary state or configuration.\n        *   This requires careful handling to ensure services are shut down correctly before the replacement.\n        *   Often better managed by an external supervisor like `systemd`.",
  "files": [
    {
      "name": "implementation_plan.md",
      "content": "## Detailed Implementation Plan for Python Service Orchestrator\n\nThis document outlines the implementation plan for the Python script responsible for managing and respawning services, building upon the refined conceptual design.\n\n**1. Module Breakdown:**\n\nThe script will be modularized to promote reusability, testability, and maintainability. Key modules include:\n\n*   **`main.py` (Orchestrator Core):**\n    *   Entry point of the script.\n    *   Initializes logging, configuration, and service manager.\n    *   Contains the main control loop for monitoring services.\n    *   Handles signal processing for graceful shutdown.\n    *   Manages the lifecycle of the Orchestrator itself (e.g., initiating self-restart if designed).\n\n*   **`config_manager.py`:**\n    *   Loads and validates service configurations from a specified file (e.g., JSON, YAML).\n    *   Provides methods to access service configurations (command, restart policy, dependencies, etc.).\n    *   Handles potential configuration file errors.\n\n*   **`service_manager.py`:**\n    *   Manages individual service processes.\n    *   `start_service(service_config)`: Uses `subprocess.Popen` to launch a service.\n    *   `stop_service(service_name)`: Sends SIGTERM to a service process.\n    *   `restart_service(service_name)`: Stops and then starts a service.\n    *   `get_service_status(service_name)`: Checks if a process is running using `Popen.poll()` or `psutil`.\n    *   Maintains a registry of running service Popen objects and their states.\n\n*   **`monitor.py`:**\n    *   Contains the logic for the main monitoring loop.\n    *   Periodically checks the status of all managed services.\n    *   Detects unexpected service terminations.\n    *   Triggers respawn actions via the `service_manager` based on defined policies.\n    *   May incorporate dependency checking before respawning.\n\n*   **`logger_config.py`:**\n    *   Sets up the logging configuration (format, level, output handlers - e.g., file, console).\n    *   Ensures consistent logging across all modules.\n\n*   **`utils.py` (Optional):**\n    *   Helper functions, e.g., for path manipulation, argument parsing, or specific OS interactions.\n\n**2. Data Structures:**\n\n*   **Service Configuration:** A dictionary or list of dictionaries, loaded from the configuration file. Each service entry should contain:\n    *   `name`: Unique identifier for the service.\n    *   `command`: The command to execute (list of strings).\n    *   `working_dir`: Optional working directory.\n    *   `environment`: Optional environment variables.\n    *   `restart_policy`: (e.g., `always`, `on-failure`, `never`).\n    *   `max_retries`: Maximum respawn attempts within a time window.\n    *   `retry_delay`: Initial delay before first retry.\n    *   `dependencies`: List of service names that must be running before this service starts.\n    *   `timeout_start`: Maximum time to wait for service to start.\n    *   `timeout_stop`: Maximum time to wait for service to stop.\n\n*   **Service State Registry:** A dictionary within `service_manager.py` to track the state of each managed service:\n    *   Key: `service_name`\n    *   Value: A dictionary containing:\n        *   `process`: The `subprocess.Popen` object.\n        *   `status`: (e.g., `PENDING`, `STARTING`, `RUNNING`, `STOPPING`, `STOPPED`, `FAILED`, `RESTARTING`).\n        *   `pid`: Process ID.\n        *   `start_time`: Timestamp of last successful start.\n        *   `retry_count`: Current number of respawn attempts.\n        *   `last_exit_code`: Exit code of the last termination.\n\n*   **Global State:** Potentially a small object or dictionary in `main.py` to hold global settings or flags (e.g., `is_shutting_down`).\n\n**3. Control Flow:**\n\n*   **Initialization:**\n    1.  `main.py` starts.\n    2.  `logger_config.py` initializes logging.\n    3.  `config_manager.py` loads and validates the service configuration file.\n    4.  `service_manager.py` initializes its internal state registry (empty).\n    5.  `monitor.py` is initialized.\n    6.  Orchestrator registers itself with its own supervisor (if applicable).\n\n*   **Service Startup Sequence:**\n    1.  The Orchestrator (in `main.py` or `monitor.py`) iterates through the loaded service configurations.\n    2.  For each service, it checks dependencies. If dependencies are not met, it waits and retries.\n    3.  Once dependencies are met (or if none exist), it calls `service_manager.start_service()`.\n    4.  `start_service` uses `subprocess.Popen`, captures the `Popen` object, updates the state registry to `STARTING`, and potentially logs the start event.\n    5.  The initial status check might confirm if it's `RUNNING` or immediately `FAILED`.\n\n*   **Monitoring Loop (in `monitor.py`):**\n    1.  Runs periodically (e.g., every 5-10 seconds).\n    2.  Iterates through the `service_state_registry` in `service_manager.py`.\n    3.  For each `RUNNING` service:\n        *   Check `process.poll()`.\n        *   If `poll()` returns an exit code (process terminated):\n            *   Record the exit code and update status to `FAILED` or `STOPPED`.\n            *   Evaluate `restart_policy`.\n            *   If restart is required and `max_retries` not exceeded, schedule a restart (potentially with a delay).\n            *   Call `service_manager.restart_service()`.\n    4.  For services marked for restart:\n        *   Perform dependency checks.\n        *   Call `service_manager.restart_service()` which calls `stop_service` then `start_service`.\n    5.  Handle new services added dynamically (if supported).\n    6.  Log any status changes or detected issues.\n\n*   **Graceful Shutdown (Signal Handling in `main.py`):**\n    1.  Catch SIGINT/SIGTERM signals.\n    2.  Set a global flag `is_shutting_down = True`.\n    3.  Iterate through all managed services in the `service_state_registry`.\n    4.  For each running service, call `service_manager.stop_service()`.\n    5.  `stop_service` sends SIGTERM to the `Popen` object and waits for a defined `timeout_stop`.\n    6.  If a service doesn't stop within the timeout, send SIGKILL.\n    7.  Once all managed services are stopped, the Orchestrator exits.\n\n*   **Self-Restart/Reload (Advanced - Optional):**\n    *   If the script needs to reload its own code or restart itself:\n        *   Use `os.exec*` to replace the current process with a new instance, passing necessary state or configuration.\n        *   This requires careful handling to ensure services are shut down correctly before the replacement.\n        *   Often better managed by an external supervisor like `systemd`."
    }
  ]
}



Please execute your sub-task, keeping the overall goal and your role's specific goal in mind to ensure your output is relevant to the project.