{
  "reasoning": "The user wants me to implement the service respawning functionality within the Python script. I have been provided with Task-Agnostic Steps (TAS) from `extracted_tas.json` (T8) and `extracted_tas.json` (T9). I need to synthesize these TAS to create a Python script snippet that addresses service respawning. The relevant TAS are 'Implement Process Monitoring', 'Implement Respawn Logic', 'Manage Process Lifecycle', 'Handle Process Errors', and 'Implement Graceful Shutdown'. I will use the `subprocess` module in Python for process management and implement a basic monitoring and respawning loop.",
  "output": "```python\nimport subprocess\nimport time\nimport sys\nimport os\n\nclass ServiceManager:\n    def __init__(self, service_configs):\n        self.service_configs = service_configs\n        self.processes = {}\n        self.running = True\n\n    def start_service(self, service_name):\n        config = self.service_configs[service_name]\n        command = config['command']\n        restart_policy = config.get('restart_policy', 'on-failure')\n        max_retries = config.get('max_retries', 5)\n        retry_delay = config.get('retry_delay', 5)\n\n        if service_name in self.processes and self.processes[service_name]['process'].poll() is None:\n            print(f\"Service {service_name} is already running.\")\n            return\n\n        try:\n            print(f\"Starting service: {service_name} with command: {command}\")\n            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            self.processes[service_name] = {\n                'process': process,\n                'command': command,\n                'restart_policy': restart_policy,\n                'max_retries': max_retries,\n                'retry_delay': retry_delay,\n                'retries': 0,\n                'start_time': time.time()\n            }\n        except Exception as e:\n            print(f\"Error starting service {service_name}: {e}\")\n            # Handle initial start failure based on policy\n            if restart_policy != 'no' and self.processes[service_name]['retries'] < max_retries:\n                self.processes[service_name]['retries'] += 1\n                print(f\"Retrying service {service_name} in {retry_delay} seconds...\")\n                time.sleep(retry_delay)\n                self.start_service(service_name) # Recursive call for retry\n            else:\n                print(f\"Failed to start service {service_name} after {max_retries} retries.\")\n\n    def stop_service(self, service_name):\n        if service_name in self.processes:\n            process_info = self.processes[service_name]\n            process = process_info['process']\n            if process.poll() is None:  # If process is running\n                print(f\"Stopping service: {service_name}\")\n                try:\n                    process.terminate() # Send SIGTERM\n                    process.wait(timeout=5) # Wait for termination\n                    print(f\"Service {service_name} stopped.\")\n                except subprocess.TimeoutExpired:\n                    print(f\"Service {service_name} did not terminate gracefully, killing.\")\n                    process.kill() # Send SIGKILL\n                    process.wait()\n                except Exception as e:\n                    print(f\"Error stopping service {service_name}: {e}\")\n            del self.processes[service_name]\n\n    def monitor_services(self):\n        for service_name, process_info in list(self.processes.items()): # Use list to allow modification during iteration\n            process = process_info['process']\n            exit_code = process.poll() # Check if process has exited\n\n            if exit_code is not None: # Process has terminated\n                print(f\"Service {service_name} terminated with exit code: {exit_code}\")\n                process_info['retries'] += 1\n                restart_policy = process_info['restart_policy']\n                max_retries = process_info['max_retries']\n                retry_delay = process_info['retry_delay']\n\n                should_restart = False\n                if restart_policy == 'always':\n                    should_restart = True\n                elif restart_policy == 'on-failure' and exit_code != 0:\n                    should_restart = True\n                elif restart_policy == 'on-abnormal-exit' and exit_code not in [0, 1]: # Example: 0 is success, 1 might be controlled exit\n                    should_restart = True\n\n                if should_restart and process_info['retries'] <= max_retries:\n                    print(f\"Restarting service {service_name} (Attempt {process_info['retries']}/{max_retries}) in {retry_delay} seconds...\")\n                    time.sleep(retry_delay)\n                    self.start_service(service_name) # Restart the service\n                else:\n                    print(f\"Service {service_name} will not be restarted (Max retries reached or policy forbids).\")\n                    del self.processes[service_name] # Remove from monitoring if not restarting\n\n    def run(self):\n        # Initial start of all services\n        for service_name in self.service_configs:\n            self.start_service(service_name)\n\n        # Monitoring loop\n        while self.running:\n            self.monitor_services()\n            time.sleep(2) # Check every 2 seconds\n\n    def shutdown(self):\n        print(\"Initiating shutdown...\")\n        self.running = False\n        for service_name in list(self.processes.keys()):\n            self.stop_service(service_name)\n        print(\"All services stopped. Exiting.\")\n\nif __name__ == \"__main__\":\n    # Example Service Configurations\n    # In a real scenario, this would likely be loaded from a config file (e.g., JSON, YAML)\n    # TAS: Load Service Configurations\n    service_configurations = {\n        \"web_server\": {\n            \"command\": \"python -m http.server 8000\",\n            \"restart_policy\": \"always\",\n            \"max_retries\": 10,\n            \"retry_delay\": 5\n        },\n        \"background_task\": {\n            \"command\": \"python background_worker.py\", # Assumes background_worker.py exists\n            \"restart_policy\": \"on-failure\",\n            \"max_retries\": 5,\n            \"retry_delay\": 10\n        },\n        \"failing_service\": {\n            \"command\": \"python failing_script.py\", # Assumes failing_script.py exists and exits with non-zero code\n            \"restart_policy\": \"on-failure\",\n            \"max_retries\": 3,\n            \"retry_delay\": 3\n        }\n    }\n\n    # TAS: Initialize Orchestrator\n    manager = ServiceManager(service_configurations)\n\n    # Handle graceful shutdown via signals\n    import signal\n    def signal_handler(sig, frame):\n        manager.shutdown()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, signal_handler) # Handle Ctrl+C\n    signal.signal(signal.SIGTERM, signal_handler) # Handle termination signal\n\n    try:\n        # TAS: Manage Service Lifecycle (through start_service and monitor_services)\n        # TAS: Monitor Service Status (within monitor_services)\n        # TAS: Implement Respawn Policy (within monitor_services)\n        # TAS: Handle Process Errors (implicitly via subprocess and try-except blocks)\n        # TAS: Implement Graceful Shutdown (via signal_handler and manager.shutdown())\n        manager.run()\n    except Exception as e:\n        print(f\"An unexpected error occurred in the main loop: {e}\")\n        manager.shutdown()\n        sys.exit(1)\n\n```",
  "files": [
    {
      "name": "service_manager.py",
      "content": "import subprocess\nimport time\nimport sys\nimport os\n\nclass ServiceManager:\n    def __init__(self, service_configs):\n        self.service_configs = service_configs\n        self.processes = {}\n        self.running = True\n\n    def start_service(self, service_name):\n        config = self.service_configs[service_name]\n        command = config['command']\n        restart_policy = config.get('restart_policy', 'on-failure')\n        max_retries = config.get('max_retries', 5)\n        retry_delay = config.get('retry_delay', 5)\n\n        if service_name in self.processes and self.processes[service_name]['process'].poll() is None:\n            print(f\"Service {service_name} is already running.\")\n            return\n\n        try:\n            print(f\"Starting service: {service_name} with command: {command}\")\n            # Use Popen for non-blocking execution\n            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid) # os.setsid to create a new process group\n            self.processes[service_name] = {\n                'process': process,\n                'command': command,\n                'restart_policy': restart_policy,\n                'max_retries': max_retries,\n                'retry_delay': retry_delay,\n                'retries': 0,\n                'start_time': time.time()\n            }\n        except Exception as e:\n            print(f\"Error starting service {service_name}: {e}\")\n            # Handle initial start failure based on policy\n            if restart_policy != 'no' and self.processes[service_name]['retries'] < max_retries:\n                self.processes[service_name]['retries'] += 1\n                print(f\"Retrying service {service_name} in {retry_delay} seconds...\")\n                time.sleep(retry_delay)\n                self.start_service(service_name) # Recursive call for retry\n            else:\n                print(f\"Failed to start service {service_name} after {max_retries} retries.\")\n\n    def stop_service(self, service_name):\n        if service_name in self.processes:\n            process_info = self.processes[service_name]\n            process = process_info['process']\n            if process.poll() is None:  # If process is running\n                print(f\"Stopping service: {service_name}\")\n                try:\n                    # Send SIGTERM to the process group\n                    os.killpg(os.getpgid(process.pid), signal.SIGTERM)\n                    process.wait(timeout=5) # Wait for termination\n                    print(f\"Service {service_name} stopped.\")\n                except subprocess.TimeoutExpired:\n                    print(f\"Service {service_name} did not terminate gracefully, killing process group.\")\n                    os.killpg(os.getpgid(process.pid), signal.SIGKILL) # Send SIGKILL to the process group\n                    process.wait()\n                except ProcessLookupError:\n                    print(f\"Service {service_name} process already terminated.\")\n                except Exception as e:\n                    print(f\"Error stopping service {service_name}: {e}\")\n            del self.processes[service_name]\n\n    def monitor_services(self):\n        for service_name, process_info in list(self.processes.items()): # Use list to allow modification during iteration\n            process = process_info['process']\n            exit_code = process.poll() # Check if process has exited\n\n            if exit_code is not None: # Process has terminated\n                print(f\"Service {service_name} terminated with exit code: {exit_code}\")\n                process_info['retries'] += 1\n                restart_policy = process_info['restart_policy']\n                max_retries = process_info['max_retries']\n                retry_delay = process_info['retry_delay']\n\n                should_restart = False\n                if restart_policy == 'always':\n                    should_restart = True\n                elif restart_policy == 'on-failure' and exit_code != 0:\n                    should_restart = True\n                elif restart_policy == 'on-abnormal-exit' and exit_code not in [0, 1]: # Example: 0 is success, 1 might be controlled exit\n                    should_restart = True\n\n                if should_restart and process_info['retries'] <= max_retries:\n                    print(f\"Restarting service {service_name} (Attempt {process_info['retries']}/{max_retries}) in {retry_delay} seconds...\")\n                    time.sleep(retry_delay)\n                    self.start_service(service_name) # Restart the service\n                else:\n                    print(f\"Service {service_name} will not be restarted (Max retries reached or policy forbids).\")\n                    del self.processes[service_name] # Remove from monitoring if not restarting\n\n    def run(self):\n        # Initial start of all services\n        for service_name in self.service_configs:\n            self.start_service(service_name)\n\n        # Monitoring loop\n        while self.running:\n            self.monitor_services()\n            time.sleep(2) # Check every 2 seconds\n\n    def shutdown(self):\n        print(\"Initiating shutdown...\")\n        self.running = False\n        for service_name in list(self.processes.keys()):\n            self.stop_service(service_name)\n        print(\"All services stopped. Exiting.\")\n\nif __name__ == \"__main__\":\n    # Example Service Configurations\n    # In a real scenario, this would likely be loaded from a config file (e.g., JSON, YAML)\n    # TAS: Load Service Configurations\n    service_configurations = {\n        \"web_server\": {\n            \"command\": \"python -m http.server 8000\",\n            \"restart_policy\": \"always\",\n            \"max_retries\": 10,\n            \"retry_delay\": 5\n        },\n        \"background_task\": {\n            \"command\": \"python background_worker.py\", # Assumes background_worker.py exists\n            \"restart_policy\": \"on-failure\",\n            \"max_retries\": 5,\n            \"retry_delay\": 10\n        },\n        \"failing_service\": {\n            \"command\": \"python failing_script.py\", # Assumes failing_script.py exists and exits with non-zero code\n            \"restart_policy\": \"on-failure\",\n            \"max_retries\": 3,\n            \"retry_delay\": 3\n        }\n    }\n\n    # TAS: Initialize Orchestrator\n    manager = ServiceManager(service_configurations)\n\n    # Handle graceful shutdown via signals\n    import signal\n    def signal_handler(sig, frame):\n        manager.shutdown()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, signal_handler) # Handle Ctrl+C\n    signal.signal(signal.SIGTERM, signal_handler) # Handle termination signal\n\n    try:\n        # TAS: Manage Service Lifecycle (through start_service and monitor_services)\n        # TAS: Monitor Service Status (within monitor_services)\n        # TAS: Implement Respawn Policy (within monitor_services)\n        # TAS: Handle Process Errors (implicitly via subprocess and try-except blocks)\n        # TAS: Implement Graceful Shutdown (via signal_handler and manager.shutdown())\n        manager.run()\n    except Exception as e:\n        print(f\"An unexpected error occurred in the main loop: {e}\")\n        manager.shutdown()\n        sys.exit(1)\n"
    }
  ]
}