{"reasoning": "The user wants me to extract Task-Agnostic Steps (TAS) from the provided implementation plan (T6). My sub-task is to identify and return each TAS towards the high-level goal: 'Python Script that loads itself and respawns services'. I need to go through the implementation plan and identify distinct, generalizable actions that can be considered TAS. Each TAS should be presented in the specified JSON format.", "output": "[{\"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\", \"name\": \"Initialize Orchestrator\", \"description\": \"Set up the core components of the service orchestration script, including logging, configuration loading, and the service management system. This involves the initial entry point and setup procedures.\", \"category\": \"Init\", \"purpose\": \"Prepare the system for operation by initializing essential modules and configurations.\", \"keywords\": [\"initialization\", \"setup\", \"logging\", \"configuration\", \"core components\"], \"applicability_notes\": \"This step is fundamental for any script that manages processes or services. The specifics of logging and configuration loading can vary, but the core action of setting up the environment remains consistent.\", \"examples_of_usage\": [\"Setting up logging and loading application settings at the start of a web server script.\", \"Initializing database connections and environment variables for a data processing pipeline.\", \"Preparing the main module for a background service that needs to manage other processes.\"], \"typical_inputs\": [\"Configuration file path\", \"Logging settings\"], \"typical_outputs\": [\"Initialized logger\", \"Loaded configuration data\", \"Ready service manager instance\"]}, {\"id\": \"b2c3d4e5-f6a7-8901-2345-67890abcdef0\", \"name\": \"Load Service Configurations\", \"description\": \"Read and validate the configuration file that defines the services to be managed. This includes parsing the file format (e.g., JSON, YAML) and ensuring all required parameters for each service are present and correctly formatted.\", \"category\": \"Configuration\", \"purpose\": \"Ingest and validate the parameters defining the services to be orchestrated.\", \"keywords\": [\"configuration\", \"load\", \"parse\", \"validate\", \"services\", \"parameters\"], \"applicability_notes\": \"Applicable whenever a system needs to manage external entities based on predefined settings. The complexity of validation depends on the number of parameters and their interdependencies.\", \"examples_of_usage\": [\"Loading user preferences from a settings file for a desktop application.\", \"Parsing a list of API endpoints and their authentication details from a config file.\", \"Reading network settings and service definitions from a YAML file for a microservice.\"], \"typical_inputs\": [\"Configuration file (e.g., JSON, YAML)\", \"Schema for validation\"], \"typical_outputs\": [\"Validated service configurations\", \"List of services to manage\"]}, {\"id\": \"c3d4e5f6-a7b8-9012-3456-7890abcdef01\", \"name\": \"Manage Service Lifecycle\", \"description\": \"Control the execution of individual services, including starting new processes, stopping existing ones, and managing their state (running, stopped, failed). This involves interacting with the operating system's process management capabilities.\", \"category\": \"Execution\", \"purpose\": \"Control the start, stop, and state transitions of managed service processes.\", \"keywords\": [\"service management\", \"process control\", \"start\", \"stop\", \"subprocess\", \"lifecycle\"], \"applicability_notes\": \"This is a core function for any process supervisor or orchestrator. It can be implemented using various OS-level tools and libraries like `subprocess` in Python.\", \"examples_of_usage\": [\"Starting a web server process using `subprocess.Popen`.\", \"Sending a termination signal to a background worker process.\", \"Monitoring the exit status of a child process.\"], \"typical_inputs\": [\"Service command and arguments\", \"Service configuration parameters (e.g., working directory, environment variables)\", \"Process ID (for stop/restart)\"], \"typical_outputs\": [\"Running process object\", \"Process status updates\", \"Termination signals sent\"]}, {\"id\": \"d4e5f6a7-b8c9-0123-4567-890abcdef012\", \"name\": \"Monitor Service Status\", \"description\": \"Continuously observe the state of managed services to detect unexpected terminations or failures. This involves periodically checking if processes are still running and their exit codes.\", \"category\": \"Monitoring\", \"purpose\": \"Track the operational status of managed services and detect anomalies.\", \"keywords\": [\"monitoring\", \"status check\", \"process polling\", \"failure detection\", \"health check\"], \"applicability_notes\": \"Essential for maintaining system availability. The frequency and method of monitoring can be adjusted based on system criticality and resource constraints.\", \"examples_of_usage\": [\"Checking if a database process is still active.\", \"Detecting if a worker script has crashed and exited unexpectedly.\", \"Periodically pinging a service's health endpoint.\"], \"typical_inputs\": [\"List of running service processes\", \"Service state registry\"], \"typical_outputs\": [\"Status updates for each service\", \"Notifications of terminated or failed services\"]}, {\"id\": \"e5f6a7b8-c9d0-1234-5678-90abcdef0123\", \"name\": \"Implement Respawn Policy\", \"description\": \"Based on detected service failures or terminations, apply predefined rules to decide whether and how to restart a service. This includes handling retry counts, delays, and specific restart conditions.\", \"category\": \"Policy Enforcement\", \"purpose\": \"Automate the recovery of failed services according to defined rules.\", \"keywords\": [\"respawn\", \"restart\", \"policy\", \"retry\", \"failure recovery\", \"automation\"], \"applicability_notes\": \"Crucial for achieving high availability. Policies can range from simple 'always restart' to complex conditional restarts based on exit codes or time windows.\", \"examples_of_usage\": [\"Restarting a web server if it crashes unexpectedly.\", \"Retrying a failed data import task after a short delay.\", \"Applying a maximum retry limit for a service that consistently fails.\"], \"typical_inputs\": [\"Detected service failure event\", \"Service configuration (restart policy, max retries)\", \"Current retry count\"], \"typical_outputs\": [\"Decision to restart service\", \"Scheduled restart action\"]}, {\"id\": \"f6a7b8c9-d0e1-2345-6789-0abcdef01234\", \"name\": \"Handle Graceful Shutdown\", \"description\": \"Implement a mechanism to stop all managed services in an orderly fashion when the orchestrator itself is shutting down. This typically involves sending termination signals and waiting for processes to exit.\", \"category\": \"Lifecycle Management\", \"purpose\": \"Ensure all managed processes are terminated cleanly during orchestrator shutdown.\", \"keywords\": [\"shutdown\", \"graceful exit\", \"termination signal\", \"process management\", \"cleanup\"], \"applicability_notes\": \"Important for data integrity and preventing orphaned processes. The implementation often involves signal handling (e.g., SIGINT, SIGTERM) and timeouts.\", \"examples_of_usage\": [\"Stopping all running applications before the operating system shuts down.\", \"Closing database connections and saving state before an application exits.\", \"Terminating child processes in a controlled manner.\"], \"typical_inputs\": [\"Shutdown signal\", \"List of running services\"], \"typical_outputs\": [\"All managed services stopped\", \"Orchestrator exits cleanly\"]}, {\"id\": \"a7b8c9d0-e1f2-3456-7890-abcdef012345\", \"name\": \"Manage Orchestrator Self-Lifecycle (Optional)\", \"description\": \"Implement logic for the orchestrator script to restart or reload itself, potentially applying configuration changes or recovering from internal errors. This might involve replacing the current process with a new instance.\", \"category\": \"Lifecycle Management\", \"purpose\": \"Enable self-healing or self-updating capabilities for the orchestrator itself.\", \"keywords\": [\"self-restart\", \"self-reload\", \"process replacement\", \"dynamic update\", \"orchestrator lifecycle\"], \"applicability_notes\": \"This is an advanced feature. Careful consideration of state management and potential race conditions is required. Often, external tools like systemd or supervisor are preferred for managing the orchestrator's own lifecycle.\", \"examples_of_usage\": [\"Replacing a running script with an updated version without manual intervention.\", \"Recovering from an internal crash by restarting the main script.\", \"Applying new configurations by reloading the orchestrator process.\"], \"typical_inputs\": [\"Internal orchestrator state\", \"New script version or configuration\"], \"typical_outputs\": [\"New orchestrator process instance\"]}]", "files": []}