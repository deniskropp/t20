The overall goal is: 'Python Script that loads itself and respawns services'

Your role's specific goal is: ''
Your specific sub-task is: 'Implement the service respawning functionality within the Python script, considering different service management approaches.'

The team's roles are:
    {'reasoning': 'The goal is to create a Python script that can load itself and respawn services. This requires a systematic approach, starting with understanding the core requirements, designing the system architecture, implementing the script, and ensuring its reliability through testing and refinement. The roles provided are diverse, and their tasks should reflect a logical progression from conceptualization to execution and maintenance. The plan is structured to first define the problem and requirements, then design the solution, followed by implementation, and finally, testing and iteration. Prompt engineering is integrated to refine agent instructions at each stage.', 'roles': [{'title': 'System Architect', 'description': 'Designs the overall structure and components of the system.'}, {'title': 'Requirements Analyst', 'description': 'Gathers and analyzes the functional and non-functional requirements of the system.'}, {'title': 'Technical Expert', 'description': 'Provides in-depth knowledge on specific technologies and implementation details.'}, {'title': 'Conceptual Analyst', 'description': 'Analyzes and refines the core concepts and logic of the system.'}, {'title': 'Researcher', 'description': 'Investigates existing solutions, libraries, and best practices.'}, {'title': 'Linguistic Mapper', 'description': 'Ensures clear and consistent communication and terminology within the project.'}, {'title': 'Lexicographer', 'description': 'Defines and standardizes the vocabulary used in the project.'}, {'title': 'Theoretical Liaison', 'description': 'Bridges theoretical concepts with practical implementation.'}, {'title': 'Relevance Assessor', 'description': 'Evaluates the relevance and applicability of proposed solutions and ideas.'}, {'title': 'Contextual Analyst', 'description': 'Analyzes the operational context and constraints of the system.'}, {'title': 'System Integrator', 'description': 'Oversees the integration of different system components.'}, {'title': 'Metrics Designer', 'description': 'Defines metrics for evaluating system performance and success.'}, {'title': 'Quality Assurance Specialist', 'description': 'Develops and executes test plans to ensure system quality.'}, {'title': 'Theoretical Advisor', 'description': 'Provides guidance on theoretical underpinnings and advanced concepts.'}, {'title': 'Feedback System', 'description': 'Designs and manages mechanisms for collecting and processing feedback.'}, {'title': 'Data Engineer', 'description': 'Handles data-related aspects, if any, in the system.'}, {'title': 'UX Researcher', 'description': "Focuses on user experience, if applicable to the script's interaction."}, {'title': 'Ingestion Specialist', 'description': 'Manages the process of bringing in necessary resources or data.'}, {'title': 'Data Validator', 'description': 'Ensures the integrity and correctness of data.'}, {'title': 'Source Integrator', 'description': 'Integrates with external data sources or services.'}, {'title': 'Theoretical Analyst', 'description': 'Analyzes theoretical aspects relevant to the project.'}, {'title': 'Pattern Recognizer', 'description': 'Identifies patterns in data or behavior for optimization.'}, {'title': 'Insight Extractor', 'description': 'Derives actionable insights from analysis.'}, {'title': 'Response Generator', 'description': 'Formulates responses or outputs based on analysis.'}, {'title': 'Theoretical Content Curator', 'description': 'Manages and organizes theoretical knowledge relevant to the project.'}, {'title': 'Context Synthesizer', 'description': 'Synthesizes information from various contexts.'}, {'title': 'Feedback Processor', 'description': 'Processes and categorizes feedback received.'}, {'title': 'Theoretical Evaluator', 'description': 'Evaluates theoretical models and approaches.'}, {'title': 'Improvement Analyst', 'description': 'Analyzes areas for improvement in the system or process.'}, {'title': 'Refinement Strategist', 'description': 'Develops strategies for refining the system.'}, {'title': 'Model Tuner', 'description': 'Adjusts parameters for optimal performance.'}, {'title': 'Workflow Designer', 'description': 'Designs and optimizes the workflow for development and execution.'}, {'title': 'Configuration Manager', 'description': 'Manages system configurations and settings.'}, {'title': 'Prompt Engineer', 'description': 'Structures workflows and ensures clarity in agent instructions, system prompt engineering.'}, {'title': 'Task-Agnostic Step Extractor', 'description': "Identifies and extracts each 'Task Agnostic Step' (TAS) towards the high-level goal."}], 'tasks': [{'task_id': 'T1', 'task': 'Define the core requirements for a Python script that can load itself and respawn services. This includes identifying essential functionalities, potential challenges, and desired outcomes.', 'role': 'Requirements Analyst', 'name': 'LaReqAnalyst', 'requires': []}, {'task_id': 'T2', 'task': 'Research existing Python libraries and techniques for self-loading scripts and service management (e.g., `importlib`, `subprocess`, systemd, supervisor).', 'role': 'Researcher', 'name': 'LaResearcher', 'requires': []}, {'task_id': 'T3', 'task': 'Analyze the theoretical underpinnings of self-modifying code and dynamic service management to ensure a robust and secure approach.', 'role': 'Theoretical Analyst', 'name': 'LaTheolAna', 'requires': []}, {'task_id': 'T4', 'task': 'Based on requirements and research, propose a high-level system architecture for the Python script, outlining key components and their interactions.', 'role': 'System Architect', 'name': 'LaSysDesigner', 'requires': ['T1', 'T2']}, {'task_id': 'T5', 'task': 'Refine the system architecture and conceptual design, ensuring logical consistency and feasibility.', 'role': 'Conceptual Analyst', 'name': 'LaConceptAna', 'requires': ['T4']}, {'task_id': 'T6', 'task': "Develop a detailed plan for the Python script's implementation, including module breakdown, data structures, and control flow.", 'role': 'Workflow Designer', 'name': 'LaWorkflowDes', 'requires': ['T5']}, {'task_id': 'T7', 'task': 'Define the prompt engineering strategy for guiding the development of the Python script, focusing on clarity and effectiveness for AI agents.', 'role': 'Prompt Engineer', 'name': 'Lyra', 'requires': ['T6']}, {'task_id': 'T8', 'task': 'Extract Task-Agnostic Steps (TAS) from the refined requirements and conceptual design to guide the implementation.', 'role': 'Task-Agnostic Step Extractor', 'name': 'TASe', 'requires': ['T5']}, {'task_id': 'T9', 'task': 'Extract Task-Agnostic Steps (TAS) from the detailed implementation plan.', 'role': 'Task-Agnostic Step Extractor', 'name': 'uTASe', 'requires': ['T6']}, {'task_id': 'T10', 'task': 'Extract Task-Agnostic Steps (TAS) from the prompt engineering strategy.', 'role': 'Task-Agnostic Step Extractor', 'name': 'GPTASe', 'requires': ['T7']}, {'task_id': 'T11', 'task': 'Implement the core logic for the Python script to load itself, potentially using dynamic import mechanisms.', 'role': 'System Integrator', 'name': 'LaSysIntegrator', 'requires': ['T8', 'T9']}, {'task_id': 'T12', 'task': 'Implement the service respawning functionality within the Python script, considering different service management approaches.', 'role': 'Technical Expert', 'name': 'LaTheoExpert', 'requires': ['T8', 'T9']}, {'task_id': 'T13', 'task': 'Integrate the self-loading and service respawning components, ensuring seamless operation.', 'role': 'System Integrator', 'name': 'LaSysIntegrator', 'requires': ['T11', 'T12']}, {'task_id': 'T14', 'task': 'Develop a configuration management strategy for the script, allowing for flexible service definitions and respawn parameters.', 'role': 'Configuration Manager', 'name': 'LaConfigMgr', 'requires': ['T13']}, {'task_id': 'T15', 'task': "Define metrics for evaluating the script's performance, reliability, and resource usage.", 'role': 'Metrics Designer', 'name': 'LaMetricsDes', 'requires': ['T1']}, {'task_id': 'T16', 'task': 'Create a comprehensive test plan, including unit tests, integration tests, and stress tests for the script.', 'role': 'Quality Assurance Specialist', 'name': 'LaQASpecialist', 'requires': ['T13', 'T15']}, {'task_id': 'T17', 'task': 'Execute the test plan and document any bugs or performance issues.', 'role': 'Quality Assurance Specialist', 'name': 'LaQASpecialist', 'requires': ['T16']}, {'task_id': 'T18', 'task': "Analyze test results and identify areas for improvement in the script's logic, efficiency, or robustness.", 'role': 'Improvement Analyst', 'name': 'LaImproveAna', 'requires': ['T17']}, {'task_id': 'T19', 'task': 'Refine the script based on feedback from testing and analysis, iterating on the implementation.', 'role': 'Refinement Strategist', 'name': 'LaRefineStrat', 'requires': ['T18']}, {'task_id': 'T20', 'task': 'Document the Python script, including its functionality, usage, configuration, and maintenance procedures.', 'role': 'Linguistic Mapper', 'name': 'LaLingMapper', 'requires': ['T19']}, {'task_id': 'T21', 'task': 'Establish a feedback loop for ongoing monitoring and improvement of the script.', 'role': 'Feedback System', 'name': 'LaFeedbackSys', 'requires': ['T20']}, {'task_id': 'T22', 'task': 'Review and refine the prompt engineering strategy based on the development process and outcomes.', 'role': 'Prompt Engineer', 'name': 'Lyra', 'requires': ['T19', 'T21']}]}

Please use the following outputs from the other agents as your input:

Artifact from 1__step_7_TASe_result.txt (Task-Agnostic Step Extractor)[T8]:
{
  "reasoning": "The user wants me to extract Task-Agnostic Steps (TAS) based on the provided conceptual design artifact (T5). My sub-task is specifically to identify these abstract steps from the refined requirements and conceptual design. I need to analyze the content of 'refined_architecture.md' and extract actions that are generalizable and reusable across different tasks, adhering to the TAS principles and the provided schema.",
  "output": "The output will be a JSON array of TAS objects.",
  "files": [
    {
      "name": "extracted_tas.json",
      "content": "[{\"id\": \"47074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Define Orchestration Strategy\", \"description\": \"Determine the primary method for managing the script's own lifecycle and the lifecycle of other services. This involves deciding between process replacement, dynamic code loading, or relying on external process supervisors for the main script, and establishing a consistent approach for child processes.\", \"category\": \"Design\", \"purpose\": \"Establish the core approach for self-management and service supervision.\", \"keywords\": [\"orchestration\", \"self-management\", \"service supervision\", \"process management\", \"strategy\"], \"applicability_notes\": \"Applicable to any system requiring automated management of its own processes or dependent services. The choice of strategy depends on the criticality, complexity, and environment.\", \"examples_of_usage\": [\"Designing a web server that restarts itself on critical errors.\", \"Creating a data processing pipeline where each stage is monitored and restarted if it fails.\", \"Building a system agent that needs to maintain continuous operation.\"], \"typical_inputs\": [\"System requirements\", \"Operational constraints\", \"Available management tools\"], \"typical_outputs\": [\"Chosen orchestration model\", \"High-level process flow\"], \"requirements_met\": \"The step describes an abstract action ('Define Strategy') applicable to managing processes. It avoids domain-specific terms like 'Python script' or 'services' in its core description, focusing on the 'how' of management. It's generalizable to various contexts requiring process control.\"}, {\"id\": \"5b074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Implement Process Monitoring\", \"description\": \"Develop mechanisms to continuously track the state and health of managed processes. This includes checking for active execution, detecting abnormal terminations (e.g., non-zero exit codes), and handling potential timeouts.\", \"category\": \"Implementation\", \"purpose\": \"Ensure the operational status of managed processes is continuously known.\", \"keywords\": [\"monitoring\", \"process state\", \"health check\", \"error detection\", \"timeout\"], \"applicability_notes\": \"Essential for any system that relies on the stable execution of one or more background processes. Applicable in areas like server management, background job processing, and distributed systems.\", \"examples_of_usage\": [\"Monitoring worker processes in a job queue system.\", \"Checking the status of database connections.\", \"Ensuring a web server process remains active.\"], \"typical_inputs\": [\"Process identifiers (PIDs)\", \"Expected process states\", \"Monitoring intervals\"], \"typical_outputs\": [\"Real-time process status\", \"Alerts for process failures\"], \"requirements_met\": \"This step abstracts the action of observing processes. 'Implement Process Monitoring' is a verb-noun phrase. It focuses on the general task of tracking process health, applicable beyond just Python or service respawning. It details typical actions like checking exit codes and handling timeouts.\"}, {\"id\": \"6c074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Implement Respawn Logic\", \"description\": \"Define and implement the automated procedure for restarting a failed or terminated process. This involves incorporating retry counts, backoff delays, and conditional restarts based on the cause of failure.\", \"category\": \"Implementation\", \"purpose\": \"Automate the recovery of failed processes.\", \"keywords\": [\"respawn\", \"restart\", \"recovery\", \"automation\", \"error handling\", \"retry strategy\"], \"applicability_notes\": \"Crucial for systems requiring high availability and fault tolerance. Applicable wherever automated restarts are needed for services, applications, or background tasks.\", \"examples_of_usage\": [\"Automatically restarting a crashed application.\", \"Rescheduling failed tasks in a batch processing system.\", \"Ensuring a network service comes back online after an unexpected shutdown.\"], \"typical_inputs\": [\"Process failure indicators\", \"Retry configuration (count, delay)\", \"Success criteria\"], \"typical_outputs\": [\"Restored process execution\", \"Updated process status\"], \"requirements_met\": \"'Implement Respawn Logic' is a clear, action-oriented TAS. It abstracts the concept of restarting processes, making it applicable to various domains. The description focuses on the general mechanisms (retries, delays) rather than specific implementation details of any single technology.\"}, {\"id\": \"7d074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Manage Process Lifecycle\", \"description\": \"Control the start, stop, and restart of managed processes according to defined rules and external triggers. This includes ensuring graceful shutdowns and handling dependencies between processes.\", \"category\": \"Implementation\", \"purpose\": \"Maintain the desired state of managed processes throughout their operation.\", \"keywords\": [\"process management\", \"lifecycle control\", \"startup\", \"shutdown\", \"dependency management\", \"state management\"], \"applicability_notes\": \"Fundamental for any system involving multiple interacting processes or services. Applicable in orchestration, microservices, and any environment where programmatic control over processes is required.\", \"examples_of_usage\": [\"Starting a sequence of services in the correct order.\", \"Gracefully stopping all components of an application before an update.\", \"Restarting a dependent service after its prerequisite has been updated.\"], \"typical_inputs\": [\"Process definitions\", \"Start/stop commands\", \"Dependency graphs\"], \"typical_outputs\": [\"Processes in the desired state\", \"Lifecycle event logs\"], \"requirements_met\": \"This TAS, 'Manage Process Lifecycle', is highly abstract and action-oriented. It describes a general capability applicable across numerous domains, focusing on the control flow of processes rather than the specific nature of those processes or the technology used to manage them.\"}, {\"id\": \"8e074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Standardize Logging\", \"description\": \"Establish a consistent format and mechanism for recording events, errors, and status updates across the system. This ensures that information is clear, traceable, and useful for debugging and auditing.\", \"category\": \"Design\", \"purpose\": \"Ensure consistent and traceable record-keeping of system activities.\", \"keywords\": [\"logging\", \"event recording\", \"error tracking\", \"traceability\", \"auditing\", \"standardization\"], \"applicability_notes\": \"Applies to any software system or process where understanding past events is important for debugging, monitoring, or compliance. Essential for complex or distributed systems.\", \"examples_of_usage\": [\"Logging user actions in a web application.\", \"Recording system errors in a background service.\", \"Tracking API call history for auditing purposes.\"], \"typical_inputs\": [\"Logging requirements\", \"Data to be logged\", \"Log destination\"], \"typical_outputs\": [\"Standardized log entries\", \"Configured logging system\"], \"requirements_met\": \"'Standardize Logging' is a general, action-oriented step. It focuses on the practice of logging rather than what is logged or where, making it broadly applicable. The description highlights the purpose (traceability, debugging) which is universal.\"}, {\"id\": \"9f074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Validate Configuration\", \"description\": \"Implement checks to ensure that system configurations are well-formed, complete, and adhere to expected formats before being applied. This prevents errors caused by invalid settings.\", \"category\": \"Implementation\", \"purpose\": \"Ensure the integrity and correctness of system configurations.\", \"keywords\": [\"configuration validation\", \"data integrity\", \"error prevention\", \"settings verification\", \"schema checking\"], \"applicability_notes\": \"Applicable to any system that relies on external configuration files or parameters. Crucial for robust and maintainable systems.\", \"examples_of_usage\": [\"Validating a JSON configuration file for a web service.\", \"Checking database connection strings for correctness.\", \"Ensuring all required parameters are present in an application's settings.\"], \"typical_inputs\": [\"Configuration data\", \"Validation rules/schema\"], \"typical_outputs\": [\"Validated configuration\", \"List of configuration errors\"], \"requirements_met\": \"'Validate Configuration' is a standard, reusable step in system development. It's a verb-noun phrase focusing on a general action applicable to any configurable system, not tied to specific technologies or domains.\"}, {\"id\": \"a0074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Handle Process Errors\", \"description\": \"Implement robust error handling for all interactions with external processes. This includes catching exceptions during process startup, monitoring, and communication, and defining appropriate fallback or recovery actions.\", \"category\": \"Implementation\", \"purpose\": \"Ensure system stability and resilience in the face of process-related issues.\", \"keywords\": [\"error handling\", \"exception management\", \"process interaction\", \"resilience\", \"fault tolerance\"], \"applicability_notes\": \"Essential for any application that manages or interacts with other processes. Applicable in service orchestration, task automation, and system monitoring.\", \"examples_of_usage\": [\"Catching 'file not found' errors when trying to execute a command.\", \"Handling permissions errors when starting a service.\", \"Implementing timeouts for inter-process communication.\"], \"typical_inputs\": [\"Potential process exceptions\", \"Error recovery strategies\"], \"typical_outputs\": [\"Graceful degradation\", \"Error logging\", \"Attempted recovery actions\"], \"requirements_met\": \"'Handle Process Errors' is a generic, action-oriented step. It describes a fundamental aspect of software development applicable to any process interaction, regardless of the programming language or the specific processes involved.\"}, {\"id\": \"b1074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Implement Graceful Shutdown\", \"description\": \"Design and implement a procedure to terminate processes and the system itself in an orderly manner, ensuring data integrity and preventing resource leaks. This involves signaling processes to stop and waiting for their completion.\", \"category\": \"Implementation\", \"purpose\": \"Ensure safe and orderly termination of processes and the system.\", \"keywords\": [\"graceful shutdown\", \"orderly termination\", \"process signaling\", \"resource cleanup\", \"data integrity\"], \"applicability_notes\": \"Critical for applications that manage resources, maintain state, or interact with other systems. Applicable to servers, daemons, and any long-running process.\", \"examples_of_usage\": [\"Shutting down a web server by closing connections and stopping worker threads.\", \"Stopping a database service by ensuring all transactions are committed.\", \"Terminating background jobs before system maintenance.\"], \"typical_inputs\": [\"Termination signals\", \"Process PIDs\", \"Shutdown timeouts\"], \"typical_outputs\": [\"Terminated processes\", \"Cleaned-up resources\", \"System shutdown\"], \"requirements_met\": \"'Implement Graceful Shutdown' is a clearly defined, action-oriented step applicable to any system that needs to be stopped cleanly. It focuses on the 'how' of termination, making it generalizable.\"}, {\"id\": \"c2074a8d-6a2e-4f8e-8c1e-3b8b7b9b8b8b\", \"name\": \"Define Dependency Management\", \"description\": \"Establish rules and mechanisms for managing the order of operations or startup sequences based on interdependencies between different components or services.\", \"category\": \"Design\", \"purpose\": \"Ensure components are started and operated in the correct, interdependent order.\", \"keywords\": [\"dependency management\", \"startup order\", \"service dependencies\", \"component sequencing\", \"interdependency\"], \"applicability_notes\": \"Essential for complex systems with multiple interacting parts. Applicable in microservice architectures, operating system services, and workflow automation.\", \"examples_of_usage\": [\"Ensuring a database service starts before the application that uses it.\", \"Sequencing deployment steps in a CI/CD pipeline.\", \"Managing task order in a complex data processing workflow.\"], \"typical_inputs\": [\"Component relationships\", \"Required startup order\"], \"typical_outputs\": [\"Dependency graph\", \"Execution plan\"], \"requirements_met\": \"'Define Dependency Management' is an abstract concept focusing on relationships and order, applicable across many domains. It's a clear verb-noun phrase representing a distinct phase in system design or implementation.\"}]"
    }
  ]
}

---

Artifact from 1__step_8_uTASe_result.txt (Task-Agnostic Step Extractor)[T9]:
{"reasoning": "The user wants me to extract Task-Agnostic Steps (TAS) from the provided implementation plan (T6). My sub-task is to identify and return each TAS towards the high-level goal: 'Python Script that loads itself and respawns services'. I need to go through the implementation plan and identify distinct, generalizable actions that can be considered TAS. Each TAS should be presented in the specified JSON format.", "output": "[{\"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\", \"name\": \"Initialize Orchestrator\", \"description\": \"Set up the core components of the service orchestration script, including logging, configuration loading, and the service management system. This involves the initial entry point and setup procedures.\", \"category\": \"Init\", \"purpose\": \"Prepare the system for operation by initializing essential modules and configurations.\", \"keywords\": [\"initialization\", \"setup\", \"logging\", \"configuration\", \"core components\"], \"applicability_notes\": \"This step is fundamental for any script that manages processes or services. The specifics of logging and configuration loading can vary, but the core action of setting up the environment remains consistent.\", \"examples_of_usage\": [\"Setting up logging and loading application settings at the start of a web server script.\", \"Initializing database connections and environment variables for a data processing pipeline.\", \"Preparing the main module for a background service that needs to manage other processes.\"], \"typical_inputs\": [\"Configuration file path\", \"Logging settings\"], \"typical_outputs\": [\"Initialized logger\", \"Loaded configuration data\", \"Ready service manager instance\"]}, {\"id\": \"b2c3d4e5-f6a7-8901-2345-67890abcdef0\", \"name\": \"Load Service Configurations\", \"description\": \"Read and validate the configuration file that defines the services to be managed. This includes parsing the file format (e.g., JSON, YAML) and ensuring all required parameters for each service are present and correctly formatted.\", \"category\": \"Configuration\", \"purpose\": \"Ingest and validate the parameters defining the services to be orchestrated.\", \"keywords\": [\"configuration\", \"load\", \"parse\", \"validate\", \"services\", \"parameters\"], \"applicability_notes\": \"Applicable whenever a system needs to manage external entities based on predefined settings. The complexity of validation depends on the number of parameters and their interdependencies.\", \"examples_of_usage\": [\"Loading user preferences from a settings file for a desktop application.\", \"Parsing a list of API endpoints and their authentication details from a config file.\", \"Reading network settings and service definitions from a YAML file for a microservice.\"], \"typical_inputs\": [\"Configuration file (e.g., JSON, YAML)\", \"Schema for validation\"], \"typical_outputs\": [\"Validated service configurations\", \"List of services to manage\"]}, {\"id\": \"c3d4e5f6-a7b8-9012-3456-7890abcdef01\", \"name\": \"Manage Service Lifecycle\", \"description\": \"Control the execution of individual services, including starting new processes, stopping existing ones, and managing their state (running, stopped, failed). This involves interacting with the operating system's process management capabilities.\", \"category\": \"Execution\", \"purpose\": \"Control the start, stop, and state transitions of managed service processes.\", \"keywords\": [\"service management\", \"process control\", \"start\", \"stop\", \"subprocess\", \"lifecycle\"], \"applicability_notes\": \"This is a core function for any process supervisor or orchestrator. It can be implemented using various OS-level tools and libraries like `subprocess` in Python.\", \"examples_of_usage\": [\"Starting a web server process using `subprocess.Popen`.\", \"Sending a termination signal to a background worker process.\", \"Monitoring the exit status of a child process.\"], \"typical_inputs\": [\"Service command and arguments\", \"Service configuration parameters (e.g., working directory, environment variables)\", \"Process ID (for stop/restart)\"], \"typical_outputs\": [\"Running process object\", \"Process status updates\", \"Termination signals sent\"]}, {\"id\": \"d4e5f6a7-b8c9-0123-4567-890abcdef012\", \"name\": \"Monitor Service Status\", \"description\": \"Continuously observe the state of managed services to detect unexpected terminations or failures. This involves periodically checking if processes are still running and their exit codes.\", \"category\": \"Monitoring\", \"purpose\": \"Track the operational status of managed services and detect anomalies.\", \"keywords\": [\"monitoring\", \"status check\", \"process polling\", \"failure detection\", \"health check\"], \"applicability_notes\": \"Essential for maintaining system availability. The frequency and method of monitoring can be adjusted based on system criticality and resource constraints.\", \"examples_of_usage\": [\"Checking if a database process is still active.\", \"Detecting if a worker script has crashed and exited unexpectedly.\", \"Periodically pinging a service's health endpoint.\"], \"typical_inputs\": [\"List of running service processes\", \"Service state registry\"], \"typical_outputs\": [\"Status updates for each service\", \"Notifications of terminated or failed services\"]}, {\"id\": \"e5f6a7b8-c9d0-1234-5678-90abcdef0123\", \"name\": \"Implement Respawn Policy\", \"description\": \"Based on detected service failures or terminations, apply predefined rules to decide whether and how to restart a service. This includes handling retry counts, delays, and specific restart conditions.\", \"category\": \"Policy Enforcement\", \"purpose\": \"Automate the recovery of failed services according to defined rules.\", \"keywords\": [\"respawn\", \"restart\", \"policy\", \"retry\", \"failure recovery\", \"automation\"], \"applicability_notes\": \"Crucial for achieving high availability. Policies can range from simple 'always restart' to complex conditional restarts based on exit codes or time windows.\", \"examples_of_usage\": [\"Restarting a web server if it crashes unexpectedly.\", \"Retrying a failed data import task after a short delay.\", \"Applying a maximum retry limit for a service that consistently fails.\"], \"typical_inputs\": [\"Detected service failure event\", \"Service configuration (restart policy, max retries)\", \"Current retry count\"], \"typical_outputs\": [\"Decision to restart service\", \"Scheduled restart action\"]}, {\"id\": \"f6a7b8c9-d0e1-2345-6789-0abcdef01234\", \"name\": \"Handle Graceful Shutdown\", \"description\": \"Implement a mechanism to stop all managed services in an orderly fashion when the orchestrator itself is shutting down. This typically involves sending termination signals and waiting for processes to exit.\", \"category\": \"Lifecycle Management\", \"purpose\": \"Ensure all managed processes are terminated cleanly during orchestrator shutdown.\", \"keywords\": [\"shutdown\", \"graceful exit\", \"termination signal\", \"process management\", \"cleanup\"], \"applicability_notes\": \"Important for data integrity and preventing orphaned processes. The implementation often involves signal handling (e.g., SIGINT, SIGTERM) and timeouts.\", \"examples_of_usage\": [\"Stopping all running applications before the operating system shuts down.\", \"Closing database connections and saving state before an application exits.\", \"Terminating child processes in a controlled manner.\"], \"typical_inputs\": [\"Shutdown signal\", \"List of running services\"], \"typical_outputs\": [\"All managed services stopped\", \"Orchestrator exits cleanly\"]}, {\"id\": \"a7b8c9d0-e1f2-3456-7890-abcdef012345\", \"name\": \"Manage Orchestrator Self-Lifecycle (Optional)\", \"description\": \"Implement logic for the orchestrator script to restart or reload itself, potentially applying configuration changes or recovering from internal errors. This might involve replacing the current process with a new instance.\", \"category\": \"Lifecycle Management\", \"purpose\": \"Enable self-healing or self-updating capabilities for the orchestrator itself.\", \"keywords\": [\"self-restart\", \"self-reload\", \"process replacement\", \"dynamic update\", \"orchestrator lifecycle\"], \"applicability_notes\": \"This is an advanced feature. Careful consideration of state management and potential race conditions is required. Often, external tools like systemd or supervisor are preferred for managing the orchestrator's own lifecycle.\", \"examples_of_usage\": [\"Replacing a running script with an updated version without manual intervention.\", \"Recovering from an internal crash by restarting the main script.\", \"Applying new configurations by reloading the orchestrator process.\"], \"typical_inputs\": [\"Internal orchestrator state\", \"New script version or configuration\"], \"typical_outputs\": [\"New orchestrator process instance\"]}]", "files": []}



Please execute your sub-task, keeping the overall goal and your role's specific goal in mind to ensure your output is relevant to the project.