{
  "reasoning": "The user wants me to act as a System Architect and propose a high-level system architecture for the Python script based on the requirements and research provided. I need to outline the key components and their interactions. The requirements (T1) emphasize self-loading, service monitoring, respawning, configuration, logging, and graceful shutdown. The research (T2) points to `importlib`, `subprocess`, `systemd`, and `supervisor` as relevant technologies. I will design a modular architecture that incorporates these aspects.",
  "output": "## High-Level System Architecture: Self-Loading & Service Respawning Script\n\nThis architecture outlines the core components and their interactions for a Python script designed to load itself and manage the lifecycle of other services.\n\n**1. Core Components:**\n\n*   **Orchestrator (Main Script):**\n    *   **Responsibility:** The central control unit. Manages its own lifecycle, loads its configuration, monitors services, and initiates respawning.\n    *   **Functionality:** \n        *   Self-initiation and management (potentially using `sys.executable` for full replacement).\n        *   Configuration loading.\n        *   Service monitoring loop.\n        *   Graceful shutdown handling.\n        *   Logging aggregation.\n*   **Configuration Manager:**\n    *   **Responsibility:** Reads, parses, and provides service definitions and restart policies from a configuration source.\n    *   **Functionality:** \n        *   Supports formats like JSON, YAML, or INI.\n        *   Defines: Service name, executable path, arguments, monitoring interval, restart strategy (e.g., max retries, backoff delay), dependencies.\n*   **Service Monitor:**\n    *   **Responsibility:** Periodically checks the status of each configured service.\n    *   **Functionality:** \n        *   Uses `psutil` or `subprocess` to check process status (PID, running state).\n        *   Detects service failures (crashes, unexpected exits).\n        *   Reports status changes to the Orchestrator.\n*   **Service Manager:**\n    *   **Responsibility:** Handles the starting, stopping, and restarting of managed services.\n    *   **Functionality:** \n        *   Uses `subprocess.Popen` to launch services.\n        *   Implements restart logic based on policies from the Configuration Manager (e.g., retry delays, rate limiting to prevent loops).\n        *   Handles graceful shutdown signals.\n*   **Logger:**\n    *   **Responsibility:** Centralized logging for all script activities and managed services.\n    *   **Functionality:** \n        *   Logs events: script startup/shutdown, configuration loading, service status changes, respawn attempts, errors.\n        *   Can output to console, files, or a remote logging service.\n*   **Dynamic Loader (Optional/Advanced):**\n    *   **Responsibility:** If the script needs to modify its *own* behavior at runtime (beyond just restarting), this component would handle dynamic code loading.\n    *   **Functionality:** \n        *   Uses `importlib` to load new modules or reload existing ones.\n        *   *Note: This adds significant complexity and potential instability; often, a simple restart of the script is sufficient.* \n\n**2. Interactions:**\n\n1.  **Initialization:** The Orchestrator starts. It loads its configuration via the Configuration Manager.\n2.  **Monitoring Loop:** The Orchestrator instructs the Service Monitor to check services at defined intervals.\n3.  **Status Check:** The Service Monitor queries the status of each service (using `psutil` or `subprocess`).\n4.  **Failure Detection:** If the Service Monitor detects a failure, it reports back to the Orchestrator.\n5.  **Respawn Trigger:** The Orchestrator instructs the Service Manager to respawn the failed service, applying restart policies (delay, retries).\n6.  **Service Operation:** The Service Manager uses `subprocess.Popen` to start the service. The Orchestrator logs these actions via the Logger.\n7.  **Shutdown:** When a shutdown signal is received, the Orchestrator instructs the Service Manager to stop all managed services gracefully before shutting down itself.\n8.  **Self-Respawn (Script):** If the Orchestrator itself crashes, an external mechanism (like `systemd`, `supervisor`, or a parent process) would be responsible for restarting the Orchestrator script. Alternatively, the Orchestrator could use `os.exec*` to replace itself upon detecting a critical internal failure, initiating a new instance with the same logic.\n\n**3. Technology Choices & Integration Points:**\n\n*   **Core Logic:** Python standard libraries (`subprocess`, `os`, `sys`, `importlib` if needed, `logging`, `threading`/`asyncio` for concurrency).\n*   **Process Management:** `subprocess` for launching and interacting with services. `psutil` for cross-platform process status checks.\n*   **Configuration:** JSON or YAML files parsed with `json` or `PyYAML` libraries.\n*   **External Management (Optional but Recommended):** For robust self-respawning of the *Orchestrator script itself*, consider using `systemd` (Linux) or `supervisor` to manage the Orchestrator process. This offloads the highest level of process supervision.\n\n**Diagrammatic Representation (Conceptual):**\n\n```\n+---------------------+      +----------------------+      +--------------------+\n| Orchestrator        |----->| Configuration Manager|----->| Service Definitions|\n| (Main Script)       |      +----------------------+      +--------------------+\n| - Self-Lifecycle    |\n| - Config Load       |      +--------------------+\n| - Monitor Control   |----->| Service Monitor      |\n| - Respawn Request   |      | - Checks Status      |\n| - Shutdown          |      +--------------------+\n+--------+------------+               |\n         |                             |\n         | (Failure Detected)          | (Status Info)\n         v                             v\n+---------------------+      +--------------------+\n| Service Manager     |<-----| Logger               |\n| - Launch Service    |      | - Logs Events        |\n| - Restart Logic     |      | - Aggregates Logs    |\n| - Stop Service      |      +--------------------+\n+--------+------------+\n         |\n         | (Uses subprocess/psutil)\n         v\n+--------------------+\n| Managed Services   |\n| (Python Scripts,   |\n|  External Apps)    |\n+--------------------+\n```",
  "files": [
    {
      "name": "system_architecture.md",
      "content": "## High-Level System Architecture: Self-Loading & Service Respawning Script\n\nThis architecture outlines the core components and their interactions for a Python script designed to load itself and manage the lifecycle of other services.\n\n**1. Core Components:**\n\n*   **Orchestrator (Main Script):**\n    *   **Responsibility:** The central control unit. Manages its own lifecycle, loads its configuration, monitors services, and initiates respawning.\n    *   **Functionality:** \n        *   Self-initiation and management (potentially using `sys.executable` for full replacement).\n        *   Configuration loading.\n        *   Service monitoring loop.\n        *   Graceful shutdown handling.\n        *   Logging aggregation.\n*   **Configuration Manager:**\n    *   **Responsibility:** Reads, parses, and provides service definitions and restart policies from a configuration source.\n    *   **Functionality:** \n        *   Supports formats like JSON, YAML, or INI.\n        *   Defines: Service name, executable path, arguments, monitoring interval, restart strategy (e.g., max retries, backoff delay), dependencies.\n*   **Service Monitor:**\n    *   **Responsibility:** Periodically checks the status of each configured service.\n    *   **Functionality:** \n        *   Uses `psutil` or `subprocess` to check process status (PID, running state).\n        *   Detects service failures (crashes, unexpected exits).\n        *   Reports status changes to the Orchestrator.\n*   **Service Manager:**\n    *   **Responsibility:** Handles the starting, stopping, and restarting of managed services.\n    *   **Functionality:** \n        *   Uses `subprocess.Popen` to launch services.\n        *   Implements restart logic based on policies from the Configuration Manager (e.g., retry delays, rate limiting to prevent loops).\n        *   Handles graceful shutdown signals.\n*   **Logger:**\n    *   **Responsibility:** Centralized logging for all script activities and managed services.\n    *   **Functionality:** \n        *   Logs events: script startup/shutdown, configuration loading, service status changes, respawn attempts, errors.\n        *   Can output to console, files, or a remote logging service.\n*   **Dynamic Loader (Optional/Advanced):**\n    *   **Responsibility:** If the script needs to modify its *own* behavior at runtime (beyond just restarting), this component would handle dynamic code loading.\n    *   **Functionality:** \n        *   Uses `importlib` to load new modules or reload existing ones.\n        *   *Note: This adds significant complexity and potential instability; often, a simple restart of the script is sufficient.*\n\n**2. Interactions:**\n\n1.  **Initialization:** The Orchestrator starts. It loads its configuration via the Configuration Manager.\n2.  **Monitoring Loop:** The Orchestrator instructs the Service Monitor to check services at defined intervals.\n3.  **Status Check:** The Service Monitor queries the status of each service (using `psutil` or `subprocess`).\n4.  **Failure Detection:** If the Service Monitor detects a failure, it reports back to the Orchestrator.\n5.  **Respawn Trigger:** The Orchestrator instructs the Service Manager to respawn the failed service, applying restart policies (delay, retries).\n6.  **Service Operation:** The Service Manager uses `subprocess.Popen` to start the service. The Orchestrator logs these actions via the Logger.\n7.  **Shutdown:** When a shutdown signal is received, the Orchestrator instructs the Service Manager to stop all managed services gracefully before shutting down itself.\n8.  **Self-Respawn (Script):** If the Orchestrator itself crashes, an external mechanism (like `systemd`, `supervisor`, or a parent process) would be responsible for restarting the Orchestrator script. Alternatively, the Orchestrator could use `os.exec*` to replace itself upon detecting a critical internal failure, initiating a new instance with the same logic.\n\n**3. Technology Choices & Integration Points:**\n\n*   **Core Logic:** Python standard libraries (`subprocess`, `os`, `sys`, `importlib` if needed, `logging`, `threading`/`asyncio` for concurrency).\n*   **Process Management:** `subprocess` for launching and interacting with services. `psutil` for cross-platform process status checks.\n*   **Configuration:** JSON or YAML files parsed with `json` or `PyYAML` libraries.\n*   **External Management (Optional but Recommended):** For robust self-respawning of the *Orchestrator script itself*, consider using `systemd` (Linux) or `supervisor` to manage the Orchestrator process. This offloads the highest level of process supervision.\n\n**Diagrammatic Representation (Conceptual):**\n\n```\n+---------------------+      +----------------------+      +--------------------+\n| Orchestrator        |----->| Configuration Manager|----->| Service Definitions|\n| (Main Script)       |      +----------------------+      +--------------------+\n| - Self-Lifecycle    |\n| - Config Load       |      +--------------------+\n| - Monitor Control   |----->| Service Monitor      |\n| - Respawn Request   |      | - Checks Status      |\n| - Shutdown          |      +--------------------+\n+--------+------------+               |\n         |                             |\n         | (Failure Detected)          | (Status Info)\n         v                             v\n+---------------------+      +--------------------+\n| Service Manager     |<-----| Logger               |\n| - Launch Service    |      | - Logs Events        |\n| - Restart Logic     |      | - Aggregates Logs    |\n| - Stop Service      |      +--------------------+\n+--------+------------+\n         |\n         | (Uses subprocess/psutil)\n         v\n+--------------------+\n| Managed Services   |\n| (Python Scripts,   |\n|  External Apps)    |\n+--------------------+\n```"
    }
  ]
}