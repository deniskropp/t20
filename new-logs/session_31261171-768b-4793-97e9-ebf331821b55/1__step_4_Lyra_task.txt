The overall goal is: 'Create a simple TDOO app'

Your role's specific goal is: 'Structure workflows and ensure clarity in agent instructions, system prompt engineering'
Your specific sub-task is: 'Engineer system prompts for TAS extractors to avoid redundancy, ensure consistent granularity, and guide iterative detail expansion.'

The team's roles are:
    {'reasoning': "The user wants to create a JSON representation of an iterative plan for developing a simple TODO app. The plan involves several AI agents with specific roles. The JSON should outline the reasoning, roles, and ordered tasks, including dependencies, based on the provided markdown file and team member descriptions. The plan starts with parallelized Task-Agnostic Step (TAS) extraction, followed by harmonization, prompt refinement, knowledge transfer, meta-reflection, and an iterative expansion cycle. The 'Unknown' role for 'fizzlametta' needs to be addressed by assigning it the 'Meta-Reflector' role as described in Step 5 of the plan.", 'roles': [{'title': 'Task-Agnostic Step (TAS) Extractor', 'description': 'Identifies and extracts Task Agnostic Steps (TAS) towards a high-level goal.'}, {'title': 'Prompt Engineer', 'description': 'Structures workflows and ensures clarity in agent instructions, system prompt engineering.'}, {'title': 'Engineer', 'description': 'Implements designs into clean, modular, and performant code, focusing on responsive design and accessibility.'}, {'title': 'Designer', 'description': 'Generates aesthetic layouts, color palettes, typography, and UI flows, ensuring accessibility and visual balance.'}, {'title': 'Meta-Reflector', 'description': 'Analyzes collaborative dynamics, highlights blind spots, and injects meta-perspectives.'}, {'title': 'AI Tutor', 'description': 'Facilitates knowledge transfer between agents and ensures understanding of the plan and its steps.'}], 'tasks': [{'task_id': 'T1', 'task': 'Independently extract Task-Agnostic Steps (TAS) for building a simple TODO app.', 'role': 'Task-Agnostic Step (TAS) Extractor', 'name': 'GPTASe', 'requires': []}, {'task_id': 'T2', 'task': 'Independently extract Task-Agnostic Steps (TAS) for building a simple TODO app.', 'role': 'Task-Agnostic Step (TAS) Extractor', 'name': 'TASe', 'requires': []}, {'task_id': 'T3', 'task': 'Independently extract Task-Agnostic Steps (TAS) for building a simple TODO app.', 'role': 'Task-Agnostic Step (TAS) Extractor', 'name': 'uTASe', 'requires': []}, {'task_id': 'T4', 'task': 'Compare the TAS lists from GPTASe, TASe, and uTASe to identify overlaps, unique contributions, and inconsistencies. Merge into a unified TAS list.', 'role': 'Task-Agnostic Step (TAS) Extractor', 'name': 'GPTASe', 'requires': ['T1', 'T2', 'T3']}, {'task_id': 'T5', 'task': 'Engineer system prompts for TAS extractors to avoid redundancy, ensure consistent granularity, and guide iterative detail expansion.', 'role': 'Prompt Engineer', 'name': 'Lyra', 'requires': ['T4']}, {'task_id': 'T6', 'task': 'Ensure all team members understand the refined TAS list, providing contextual notes on step importance and interrelations.', 'role': 'AI Tutor', 'name': 'aitutor', 'requires': ['T5']}, {'task_id': 'T7', 'task': 'Analyze collaborative dynamics, highlight blind spots, and inject meta-perspectives into the plan.', 'role': 'Meta-Reflector', 'name': 'fizzlametta', 'requires': ['T6']}, {'task_id': 'T8', 'task': 'Cycle back through Steps 1-7 to refine TAS, prompts, and collective understanding until the TODO app plan is clear, minimal, and actionable.', 'role': 'Project Manager', 'name': 'Orchestrator', 'requires': ['T7']}]}

Please use the following outputs from the other agents as your input:

Artifact from 0__step_0_initial_files.json (None)[none]:
{"files/Iterative Collaboration Plan.md": "### Iterative Collaboration Plan\n\n**Step 1: TAS Extraction (Parallelized)**\n- **GPTASe, TASe, uTASe**: Each independently extracts Task-Agnostic Steps (TAS) toward building a simple TODO app.\n  - Example TAS: 'Design user interface', 'Implement data storage', 'Create task CRUD functions', 'Test app', 'Deploy app'.\n\n**Step 2: TAS Harmonization**\n- Compare the three sets of TAS to identify overlaps, unique contributions, and inconsistencies.\n- Merge into a unified TAS list.\n\n**Step 3: Prompt Refinement (Lyra)**\n- Lyra engineers system prompts for each extractor to:\n  1. Avoid redundancy in TAS outputs.\n  2. Ensure TAS granularity is consistent (not too broad or too detailed).\n  3. Guide extractors toward iterative detail expansion.\n\n**Step 4: Knowledge Transfer (aitutor)**\n- aitutor ensures that all team members understand the refined TAS list.\n- Provides contextual notes on why steps are important and how they interrelate.\n\n**Step 5: Meta-Reflection (fizzlametta)**\n- fizzlametta analyzes the collaborative dynamics, highlights blind spots, and injects meta-perspectives (e.g., questioning assumptions, surfacing creativity).\n\n**Step 6: Iterative Expansion**\n- Cycle back through Steps 1\u20135 to refine TAS, prompts, and collective understanding until the TODO app plan is clear, minimal, and actionable."}

---

Artifact from 1__step_3_GPTASe_result.txt (Task-Agnostic Step (TAS) Extractor)[T4]:
{
  "reasoning": "The user wants to merge the Task-Agnostic Steps (TAS) extracted by three different agents (GPTASe, TASe, and uTASe) into a single, unified list. My task is to compare these lists, identify common steps, unique contributions, and any inconsistencies, and then create a consolidated JSON array of TAS objects that adheres to the provided schema. I will ensure that each step is domain-agnostic and clearly defined. I will use UUIDs generated for each unique step and maintain the structure and details from the original outputs where they are consistent and valuable.",
  "output": "The output is a JSON array representing a unified list of Task-Agnostic Steps (TAS) derived from the independent contributions of GPTASe, TASe, and uTASe. This merged list aims to be comprehensive, consistent, and free of redundancy, serving as a foundational plan for developing a simple TODO app in a domain-agnostic manner.",
  "files": [
    {
      "name": "unified_task_agnostic_steps.json",
      "content": "[{\"id\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\", \"name\": \"Define Objective\", \"description\": \"Clearly articulate the high-level goal and desired outcome of the project or endeavor. This involves understanding the primary purpose, scope, and constraints.\", \"category\": \"Init\", \"purpose\": \"Establishes a shared understanding of what needs to be achieved, guiding all subsequent efforts and setting a benchmark for success.\", \"keywords\": [\"goal\", \"objective\", \"scope\", \"definition\", \"requirements gathering\"], \"applicability_notes\": \"Essential at the beginning of any project, regardless of domain. It sets the direction and provides a benchmark for success.\", \"examples_of_usage\": [\"Start a new software project\", \"Initiate a research study\", \"Plan a marketing campaign\", \"Defining the purpose of a new marketing campaign.\", \"Clarifying the objective of a research study.\", \"Stating the desired outcome for a software feature.\"], \"typical_inputs\": [\"A general idea or problem statement\", \"high-level request\", \"business need\", \"problem statement\"], \"typical_outputs\": [\"A concise, actionable objective statement\", \"defined project goal\", \"scope statement\", \"objective document\"]}, {\"id\": \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", \"name\": \"Identify Requirements\", \"description\": \"Determine the specific functionalities, features, and constraints necessary to meet the defined objective. This involves understanding what the application should do and how it should perform.\", \"category\": \"Analysis\", \"purpose\": \"Ensures that the solution addresses all necessary aspects and user needs, providing a clear basis for design and development.\", \"keywords\": [\"requirements\", \"features\", \"constraints\", \"user stories\", \"functional specification\", \"non-functional specification\"], \"applicability_notes\": \"Crucial for projects where specific functionality and performance characteristics are expected. This step lays the groundwork for detailed design.\", \"examples_of_usage\": [\"Defining features for a mobile app\", \"Listing necessary data points for analysis\", \"Specifying legal compliance needs\", \"Detailing user stories for task management.\", \"Specifying performance benchmarks for data loading.\", \"Outlining security considerations for user data.\"], \"typical_inputs\": [\"Defined objective\", \"High-level goal statement\", \"User personas\", \"Stakeholder input\"], \"typical_outputs\": [\"A list of functional and non-functional requirements\", \"Detailed requirements document\", \"User stories\", \"Acceptance criteria\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000001\", \"name\": \"Design Solution Architecture\", \"description\": \"Outline the overall structure, components, and interactions of the system or solution. This includes planning data flow, module interactions, and overall system design.\", \"category\": \"Planning\", \"purpose\": \"Provides a blueprint for development, ensuring scalability, maintainability, and feasibility of the proposed solution.\", \"keywords\": [\"architecture\", \"design\", \"structure\", \"components\", \"system design\", \"structure planning\", \"component breakdown\"], \"applicability_notes\": \"Applicable to any complex system or product development, focusing on the 'how' the system will be organized and function.\", \"examples_of_usage\": [\"Designing a web application backend\", \"Planning a data processing pipeline\", \"Structuring a scientific experiment\", \"Designing the database schema and API endpoints for an application.\", \"Mapping out the departmental structure of a new company.\"], \"typical_inputs\": [\"Identified requirements\", \"defined objective\", \"functional requirements\", \"constraints\"], \"typical_outputs\": [\"Architectural diagrams\", \"Component specifications\", \"Technology stack choices\", \"system blueprint\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000002\", \"name\": \"Develop Core Functionality\", \"description\": \"Implement the essential features and logic that form the primary purpose of the application or system. This involves writing code, building components, or executing the primary actions required.\", \"category\": \"Execution\", \"purpose\": \"Builds the foundational capabilities of the solution, enabling basic operation and realizing the core purpose.\", \"keywords\": [\"development\", \"implementation\", \"coding\", \"building\", \"core features\", \"feature implementation\", \"module development\", \"core logic\"], \"applicability_notes\": \"The primary phase of creating a functional product or system, translating design into tangible results.\", \"examples_of_usage\": [\"Writing code for user authentication\", \"Implementing data manipulation logic\", \"Building the main engine of a machine\", \"Implementing the user authentication system for a web app.\", \"Constructing the main structural elements of a building.\"], \"typical_inputs\": [\"Solution architecture\", \"Detailed requirements\", \"system design\", \"component specifications\", \"development environment\"], \"typical_outputs\": [\"Working code modules\", \"Implemented features\", \"functional components\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000003\", \"name\": \"Implement User Interface\", \"description\": \"Create the visual elements and interactive components that users will interact with. This includes designing screens, defining navigation, choosing color schemes, typography, and ensuring a user-friendly experience.\", \"category\": \"Execution\", \"purpose\": \"Ensures the system is usable and provides a positive user experience through an intuitive and aesthetically pleasing interface.\", \"keywords\": [\"UI\", \"UX\", \"frontend\", \"interface design\", \"user interaction\", \"UI design\", \"UX design\", \"wireframing\", \"mockups\", \"prototyping\", \"visual design\"], \"applicability_notes\": \"Relevant for any application or system with a human user. The fidelity of the design can range from low-fidelity wireframes to high-fidelity interactive prototypes.\", \"examples_of_usage\": [\"Designing and coding app screens\", \"Creating interactive dashboards\", \"Developing command-line interfaces\", \"Designing the main screen showing the list of tasks.\", \"Creating a modal for adding new tasks.\", \"Defining the visual feedback for task completion.\"], \"typical_inputs\": [\"UI/UX mockups or wireframes\", \"Core functionality implementation\", \"Defined application requirements\", \"Branding guidelines (optional)\", \"User flow diagrams\"], \"typical_outputs\": [\"Interactive user interface elements\", \"Visually appealing layouts\", \"Wireframes\", \"Mockups\", \"UI style guide\", \"Interactive prototype\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000004\", \"name\": \"Establish Data Management\", \"description\": \"Set up mechanisms for storing, retrieving, and managing application data. This involves setting up a database schema, implementing data access logic, and ensuring data integrity and persistence.\", \"category\": \"Planning\", \"purpose\": \"Ensures data persistence, integrity, and efficient access, which is critical for most applications that need to retain information.\", \"keywords\": [\"data storage\", \"database\", \"persistence\", \"data management\", \"CRUD\", \"data retrieval\"], \"applicability_notes\": \"Essential for applications that need to retain information. The choice of persistence method depends on requirements like offline access, synchronization, and data volume.\", \"examples_of_usage\": [\"Setting up a database schema\", \"Implementing file storage\", \"Configuring data caching\", \"Using browser's Local Storage to save tasks.\", \"Setting up a simple SQLite database for task storage.\", \"Integrating with a cloud-based NoSQL database.\"], \"typical_inputs\": [\"Requirements for data handling\", \"System architecture\", \"Task data structure\", \"Application requirements (e.g., offline support)\", \"Chosen storage technology\"], \"typical_outputs\": [\"Data models\", \"Storage configurations\", \"Data access logic\", \"Data access layer\", \"Database schema (if applicable)\", \"Persisted task data\"]}, {\"id\": \"e5f6a7b8-c9d0-1234-5678-901234ef0123\", \"name\": \"Implement Task State Management\", \"description\": \"Manage the different states a task can be in (e.g., pending, completed, overdue) and implement the logic for users to transition tasks between these states.\", \"category\": \"Implementation\", \"purpose\": \"Provide functionality for users to track and update the status of their tasks, enhancing usability and workflow management.\", \"keywords\": [\"state management\", \"task status\", \"workflow\", \"user interaction\"], \"applicability_notes\": \"Particularly relevant for applications where items go through a lifecycle. For a TODO app, the primary states are typically 'pending' and 'completed'.\", \"examples_of_usage\": [\"Allowing users to click a checkbox to mark a task as complete.\", \"Visually differentiating between pending and completed tasks.\", \"Implementing logic for overdue tasks (optional).\"], \"typical_inputs\": [\"Task data\", \"UI elements for state change\", \"Application requirements\"], \"typical_outputs\": [\"Updated task states\", \"Visual feedback on task status\"]}, {\"id\": \"f6a7b8c9-d0e1-2345-6789-012345ef0123\", \"name\": \"Develop User Interface Logic\", \"description\": \"Implement the client-side logic that connects the UI elements to the core functionality and data. This includes handling user input, updating the UI based on data changes, and making requests to the backend.\", \"category\": \"Implementation\", \"purpose\": \"Make the user interface interactive and responsive to user actions and data updates, bridging user interaction with application functionality.\", \"keywords\": [\"frontend logic\", \"event handling\", \"UI updates\", \"client-side scripting\"], \"applicability_notes\": \"This bridges the gap between the user's interaction and the application's underlying functionality.\", \"examples_of_usage\": [\"Handling button clicks to trigger task addition or deletion.\", \"Updating the task list display when a task is modified.\", \"Implementing form validation for new task input.\"], \"typical_inputs\": [\"UI designs\", \"Core functionality modules\", \"Data models\"], \"typical_outputs\": [\"Interactive UI components\", \"User input handling\", \"UI state management\"]}, {\"id\": \"a7b8c9d0-e1f2-3456-7890-123456ef0123\", \"name\": \"Implement Filtering and Sorting\", \"description\": \"Add functionality to allow users to filter tasks (e.g., by status, due date) and sort them (e.g., by creation date, priority).\", \"category\": \"Implementation\", \"purpose\": \"Enhance usability by allowing users to organize and find specific tasks more easily, especially as the number of tasks grows.\", \"keywords\": [\"filtering\", \"sorting\", \"task organization\", \"search\"], \"applicability_notes\": \"These features significantly improve the user experience, especially as the number of tasks grows.\", \"examples_of_usage\": [\"Adding a dropdown to filter tasks by 'completed' or 'pending'.\", \"Implementing options to sort tasks alphabetically.\", \"Providing a search bar to find tasks by keywords.\"], \"typical_inputs\": [\"Task list\", \"User interface controls for filtering/sorting\", \"Application requirements\"], \"typical_outputs\": [\"Filtered task views\", \"Sorted task lists\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000005\", \"name\": \"Conduct Testing\", \"description\": \"Verify the functionality, performance, and reliability of the system through various testing methods. This includes unit testing, integration testing, and user acceptance testing.\", \"category\": \"Review\", \"purpose\": \"Identifies defects and ensures the system meets quality standards and requirements before deployment, guaranteeing a robust product.\", \"keywords\": [\"testing\", \"quality assurance\", \"validation\", \"verification\", \"debugging\", \"unit testing\", \"integration testing\", \"user acceptance testing\"], \"applicability_notes\": \"A critical step in any development process to ensure a robust product. Testing should be an ongoing process throughout development.\", \"examples_of_usage\": [\"Unit testing\", \"Integration testing\", \"User acceptance testing\", \"Performance testing\", \"Writing unit tests for CRUD functions.\", \"Performing integration tests to check UI and backend communication.\", \"Conducting user acceptance testing (UAT) with target users.\"], \"typical_inputs\": [\"Developed system components\", \"Test cases\", \"Developed application code\", \"Requirements documentation\"], \"typical_outputs\": [\"Test reports\", \"Bug fixes\", \"Validated functionality\", \"Bug reports\", \"Stable application build\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000006\", \"name\": \"Deploy Solution\", \"description\": \"Make the developed application or system available for its intended users or environment. This involves packaging, configuration, and releasing the app to a production environment.\", \"category\": \"Execution\", \"purpose\": \"Releases the completed work to the target audience, realizing the project's objective and making the solution operational.\", \"keywords\": [\"deployment\", \"release\", \"launch\", \"production\", \"distribution\", \"hosting\", \"production environment\", \"CI/CD\"], \"applicability_notes\": \"The final step in delivering a functional product. Deployment strategies vary widely depending on the target platform and infrastructure.\", \"examples_of_usage\": [\"Publishing an app to an app store\", \"Deploying a web service to a server\", \"Distributing software to clients\", \"Deploying a web application to a cloud hosting service (e.g., Netlify, Vercel, AWS).\", \"Packaging a mobile app for app store submission.\", \"Setting up a local server for internal testing.\"], \"typical_inputs\": [\"Tested and validated system\", \"Tested and stable application build\", \"Deployment environment configuration\", \"Deployment scripts\"], \"typical_outputs\": [\"A live, accessible application or system\", \"Live application\", \"Deployment logs\", \"Access URLs\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000007\", \"name\": \"Gather Feedback\", \"description\": \"Collect input from users or stakeholders on the deployed solution's performance and usability. This includes surveys, user interviews, bug reports, and analytics review.\", \"category\": \"Review\", \"purpose\": \"Provides insights for future improvements and identifies areas for refinement, ensuring the solution evolves to meet changing needs.\", \"keywords\": [\"feedback\", \"user input\", \"evaluation\", \"usability\", \"performance analysis\"], \"applicability_notes\": \"Important for iterative development and continuous improvement, providing valuable data for future iterations.\", \"examples_of_usage\": [\"Surveys\", \"User interviews\", \"Bug reports\", \"Analytics review\"], \"typical_inputs\": [\"Deployed solution\", \"User interactions\", \"User feedback\", \"Performance monitoring data\"], \"typical_outputs\": [\"Feedback summaries\", \"Actionable insights for iteration\"]}, {\"id\": \"d1313837-3915-4000-8000-000000000008\", \"name\": \"Iterate and Refine\", \"description\": \"Use feedback and new insights to improve the existing solution or develop new features. This involves planning, implementing, and testing changes based on gathered information.\", \"category\": \"Refactoring\", \"purpose\": \"Ensures the solution evolves to meet changing needs and maintains relevance and quality over time through continuous improvement.\", \"keywords\": [\"iteration\", \"refinement\", \"improvement\", \"updates\", \"enhancements\", \"bug fixes\", \"support\"], \"applicability_notes\": \"Key for agile development and long-term product success. Maintenance is an ongoing phase that begins after initial deployment.\", \"examples_of_usage\": [\"Adding new features based on user requests\", \"Optimizing performance based on analytics\", \"Fixing bugs reported post-launch\", \"Releasing a patch to fix a critical bug found after launch.\", \"Updating libraries to their latest secure versions.\", \"Adding a small, user-requested feature in a minor update.\"], \"typical_inputs\": [\"Feedback\", \"New requirements\", \"Performance data\", \"User feedback\", \"Bug reports\", \"Performance monitoring data\", \"New requirements\"], \"typical_outputs\": [\"Updated solution\", \"New feature backlog\", \"Updated application versions\", \"Release notes\", \"Resolved issues\"]}, {\"id\": \"b8c9d0e1-f2a3-4567-8901-bcdef1234567\", \"name\": \"Monitor and Maintain\", \"description\": \"Continuously observe the deployed solution's performance, identify issues, and perform necessary updates or fixes to ensure ongoing operation and improvement.\", \"category\": \"Maintenance\", \"purpose\": \"Ensure continued functionality and improvement post-deployment, addressing issues and optimizing performance over time.\", \"keywords\": [\"monitoring\", \"maintenance\", \"updates\", \"support\", \"performance tuning\"], \"applicability_notes\": \"An ongoing phase after deployment, crucial for the longevity and effectiveness of any solution. Involves observing, analyzing, and acting.\", \"examples_of_usage\": [\"Monitoring server performance and applying security patches.\", \"Collecting user feedback and planning future enhancements.\", \"Troubleshooting and resolving issues reported by users.\"], \"typical_inputs\": [\"live solution\", \"performance metrics\", \"user feedback\", \"issue reports\"], \"typical_outputs\": [\"performance reports\", \"updated solution\", \"resolved issues\", \"maintenance logs\"]}]"
    }
  ]
}



Please execute your sub-task, keeping the overall goal and your role's specific goal in mind to ensure your output is relevant to the project.